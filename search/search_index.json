{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Treeo A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo lets you easily create class-based Pytrees so your custom objects can easily interact seamlessly with JAX. Uses of Treeo can range from just creating simple simple JAX-aware utility classes to using it as the core abstraction for full-blown frameworks. Treeo was originally extracted from the core of Treex and shares a lot in common with flax.struct . Documentation | User Guide Installation Install using pip: pip install treeo Basics With Treeo you can easily define your own custom Pytree classes by inheriting from Treeo's Tree class and using the field function to declare which fields are nodes (children) and which are static (metadata): import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! field is just a wrapper around dataclasses.field so you can define your Pytrees as dataclasses, but Treeo fully supports non-dataclass classes as well. Since all Tree instances are Pytree they work with the various functions from the jax library as expected: p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John') Kinds Treeo also include a kind system that lets you give semantic meaning to fields (what a field represents within your application). A kind is just a type you pass to field via its kind argument: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) Kinds are very useful as a filtering mechanism via treeo.filter : model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) Nothing behaves like None in Python, but it is a special value that is used to represent the absence of a value within Treeo. Treeo also offers the merge function which lets you rejoin filtered Trees with a logic similar to Python dict.update but done recursively: def loss_fn ( params , model , ... ): # add traced params to model model = to . merge ( model , params ) ... # gradient only w.r.t. params params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... ) For a more in-depth tour check out the User Guide . Examples A simple Tree from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 ) A Stateful Tree from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) @jax . jit def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree Full Example - Linear Regression import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import treeo as to class Linear ( to . Tree ): w : jnp . ndarray = to . node () b : jnp . ndarray = to . node () def __init__ ( self , din , dout , key ): self . w = jax . random . uniform ( key , shape = ( din , dout )) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @jax . value_and_grad def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad @jax . jit def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) model = jax . tree_map ( sgd , model , grads ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) key = jax . random . PRNGKey ( 0 ) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Getting Started"},{"location":"#treeo","text":"A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo lets you easily create class-based Pytrees so your custom objects can easily interact seamlessly with JAX. Uses of Treeo can range from just creating simple simple JAX-aware utility classes to using it as the core abstraction for full-blown frameworks. Treeo was originally extracted from the core of Treex and shares a lot in common with flax.struct . Documentation | User Guide","title":"Treeo"},{"location":"#installation","text":"Install using pip: pip install treeo","title":"Installation"},{"location":"#basics","text":"With Treeo you can easily define your own custom Pytree classes by inheriting from Treeo's Tree class and using the field function to declare which fields are nodes (children) and which are static (metadata): import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! field is just a wrapper around dataclasses.field so you can define your Pytrees as dataclasses, but Treeo fully supports non-dataclass classes as well. Since all Tree instances are Pytree they work with the various functions from the jax library as expected: p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John')","title":"Basics"},{"location":"#kinds","text":"Treeo also include a kind system that lets you give semantic meaning to fields (what a field represents within your application). A kind is just a type you pass to field via its kind argument: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) Kinds are very useful as a filtering mechanism via treeo.filter : model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) Nothing behaves like None in Python, but it is a special value that is used to represent the absence of a value within Treeo. Treeo also offers the merge function which lets you rejoin filtered Trees with a logic similar to Python dict.update but done recursively: def loss_fn ( params , model , ... ): # add traced params to model model = to . merge ( model , params ) ... # gradient only w.r.t. params params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... ) For a more in-depth tour check out the User Guide .","title":"Kinds"},{"location":"#examples","text":"","title":"Examples"},{"location":"#a-simple-tree","text":"from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 )","title":"A simple Tree"},{"location":"#a-stateful-tree","text":"from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) @jax . jit def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree","title":"A Stateful Tree"},{"location":"#full-example-linear-regression","text":"import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import treeo as to class Linear ( to . Tree ): w : jnp . ndarray = to . node () b : jnp . ndarray = to . node () def __init__ ( self , din , dout , key ): self . w = jax . random . uniform ( key , shape = ( din , dout )) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @jax . value_and_grad def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad @jax . jit def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) model = jax . tree_map ( sgd , model , grads ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) key = jax . random . PRNGKey ( 0 ) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Full Example - Linear Regression"},{"location":"api/Apply/","text":"treeo.Apply Mixin that adds a .apply() method to the class. apply ( self , f , * rest , * , inplace = False ) apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return tree_m . apply ( f , self , * rest , inplace = inplace )","title":"Apply"},{"location":"api/Apply/#treeoapply","text":"Mixin that adds a .apply() method to the class.","title":"treeo.Apply"},{"location":"api/Apply/#treeo.mixins.Apply.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return tree_m . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/ArrayLike/","text":"treeo.ArrayLike","title":"ArrayLike"},{"location":"api/ArrayLike/#treeoarraylike","text":"","title":"treeo.ArrayLike"},{"location":"api/Compact/","text":"treeo.Compact first_run : bool property readonly Returns: Type Description bool True if its currently the first run of a compact method. get_field ( self , field_name , initializer ) A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () with tree_m . _make_mutable_single ( self ): setattr ( self , field_name , value ) return value","title":"Compact"},{"location":"api/Compact/#treeocompact","text":"","title":"treeo.Compact"},{"location":"api/Compact/#treeo.mixins.Compact.first_run","text":"Returns: Type Description bool True if its currently the first run of a compact method.","title":"first_run"},{"location":"api/Compact/#treeo.mixins.Compact.get_field","text":"A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: The field must be declared in the class definition. The method can only be called inside a compact context. Parameters: Name Type Description Default field_name str The name of the field to get. required initializer Callable[[], ~A] The function to initialize the field if it does not exist. required Returns: Type Description ~A The field value. Source code in treeo/mixins.py def get_field ( self , field_name : str , initializer : tp . Callable [[], A ], ) -> A : \"\"\" A method that gets a field with the given name if exists, otherwise it initializes it and returns it. Currently the follow restrictions apply: * The field must be declared in the class definition. * The method can only be called inside a `compact` context. Arguments: field_name: The name of the field to get. initializer: The function to initialize the field if it does not exist. Returns: The field value. \"\"\" value : A if field_name not in self . _field_metadata : raise ValueError ( f \"Metadata for field ' { field_name } ' does not exist.\" ) if field_name in vars ( self ): value = getattr ( self , field_name ) else : if tree_m . _COMPACT_CONTEXT . in_compact and not self . first_run : raise RuntimeError ( f \"Trying to initialize field ' { field_name } ' after the first run of `compact`.\" ) value = initializer () with tree_m . _make_mutable_single ( self ): setattr ( self , field_name , value ) return value","title":"get_field()"},{"location":"api/Copy/","text":"treeo.Copy Mixin that adds a .copy() method to the class. copy ( self ) copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"Copy"},{"location":"api/Copy/#treeocopy","text":"Mixin that adds a .copy() method to the class.","title":"treeo.Copy"},{"location":"api/Copy/#treeo.mixins.Copy.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self : A ) -> A : \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return tree_m . copy ( self )","title":"copy()"},{"location":"api/Extensions/","text":"treeo.Extensions Mixin that adds all available mixins from treeo.mixins except KindMixin .","title":"Extensions"},{"location":"api/Extensions/#treeoextensions","text":"Mixin that adds all available mixins from treeo.mixins except KindMixin .","title":"treeo.Extensions"},{"location":"api/FieldInfo/","text":"treeo.FieldInfo","title":"FieldInfo"},{"location":"api/FieldInfo/#treeofieldinfo","text":"","title":"treeo.FieldInfo"},{"location":"api/FieldMetadata/","text":"treeo.FieldMetadata","title":"FieldMetadata"},{"location":"api/FieldMetadata/#treeofieldmetadata","text":"","title":"treeo.FieldMetadata"},{"location":"api/Filter/","text":"treeo.Filter Mixin that adds a .filter() method to the class. filter ( self , * filters , * , inplace = False , flatten_mode = None ) filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"Filter"},{"location":"api/Filter/#treeofilter","text":"Mixin that adds a .filter() method to the class.","title":"treeo.Filter"},{"location":"api/Filter/#treeo.mixins.Filter.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/FlattenMode/","text":"treeo.FlattenMode An enumeration.","title":"FlattenMode"},{"location":"api/FlattenMode/#treeoflattenmode","text":"An enumeration.","title":"treeo.FlattenMode"},{"location":"api/Hashable/","text":"treeo.Hashable A hashable immutable wrapper around non-hashable values","title":"Hashable"},{"location":"api/Hashable/#treeohashable","text":"A hashable immutable wrapper around non-hashable values","title":"treeo.Hashable"},{"location":"api/Immutable/","text":"treeo.Immutable Mixin that makes a class immutable. It adds a .replace() and .mutable() methods to the class which let you modify the state by creating a new objects. mutable ( self , * args , * , method = '__call__' , ** kwargs ) Calls a method that contains stateful/mutable operations in an immutable fashion. mutable will let you perform stateful operations but all update will be performed other a new instance which is returned as the second output. Examples: @dataclass class MyTree ( to . Tree , to . Immutable ): total : int = to . node () def accumulate ( self , inc ) -> None : self . total += inc return self . total tree0 = MyTree ( total = 1 ) # increment by 10 total , tree = tree . mutable ( 10 , method = \"accumulate\" ) assert total == 11 Parameters: Name Type Description Default *args The positional arguments to pass to the method. () method Union[str, Callable] The method to call, can be a string with the method name, a bounded method, or a function that takes the object as first argument. '__call__' **kwargs The keyword arguments to pass to the method. {} Returns: Type Description Tuple[Any, ~A] A (output, tree) tuple containing the output of the method and the updated tree. Source code in treeo/mixins.py def mutable ( self : A , * args , method : tp . Union [ str , tp . Callable ] = \"__call__\" , ** kwargs , ) -> tp . Tuple [ tp . Any , A ]: \"\"\" Calls a method that contains stateful/mutable operations in an immutable fashion. `mutable` will let you perform stateful operations but all update will be performed other a new instance which is returned as the second output. Example: ```python @dataclass class MyTree(to.Tree, to.Immutable): total: int = to.node() def accumulate(self, inc) -> None: self.total += inc return self.total tree0 = MyTree(total=1) # increment by 10 total, tree = tree.mutable(10, method=\"accumulate\") assert total == 11 ``` Arguments: *args: The positional arguments to pass to the method. method: The method to call, can be a string with the method name, a bounded method, or a function that takes the object as first argument. **kwargs: The keyword arguments to pass to the method. Returns: A (output, tree) tuple containing the output of the method and the updated tree. \"\"\" unbounded_method : tp . Callable = ( getattr ( self . __class__ , method ) if isinstance ( method , str ) else method . __func__ if inspect . ismethod ( method ) else method ) return api . mutable ( unbounded_method )( self , * args , ** kwargs ) replace ( self , ** kwargs ) Returns a copy of the Tree with the given fields specified in kwargs updated to the new values. Examples: @dataclass class MyTree ( to . Tree , to . Immutable ): x : int = to . node () tree = MyTree ( x = 1 ) # increment x by 1 tree = tree . replace ( x = tree . x + 1 ) Parameters: Name Type Description Default **kwargs The fields to update. {} Returns: Type Description ~A A new Tree with the updated fields. Source code in treeo/mixins.py def replace ( self : A , ** kwargs ) -> A : \"\"\" Returns a copy of the Tree with the given fields specified in `kwargs` updated to the new values. Example: ```python @dataclass class MyTree(to.Tree, to.Immutable): x: int = to.node() tree = MyTree(x=1) # increment x by 1 tree = tree.replace(x=tree.x + 1) ``` Arguments: **kwargs: The fields to update. Returns: A new Tree with the updated fields. \"\"\" tree = tree_m . copy ( self ) with tree_m . _make_mutable_single ( tree ): for key , value in kwargs . items (): setattr ( tree , key , value ) return tree","title":"Immutable"},{"location":"api/Immutable/#treeoimmutable","text":"Mixin that makes a class immutable. It adds a .replace() and .mutable() methods to the class which let you modify the state by creating a new objects.","title":"treeo.Immutable"},{"location":"api/Immutable/#treeo.mixins.Immutable.mutable","text":"Calls a method that contains stateful/mutable operations in an immutable fashion. mutable will let you perform stateful operations but all update will be performed other a new instance which is returned as the second output. Examples: @dataclass class MyTree ( to . Tree , to . Immutable ): total : int = to . node () def accumulate ( self , inc ) -> None : self . total += inc return self . total tree0 = MyTree ( total = 1 ) # increment by 10 total , tree = tree . mutable ( 10 , method = \"accumulate\" ) assert total == 11 Parameters: Name Type Description Default *args The positional arguments to pass to the method. () method Union[str, Callable] The method to call, can be a string with the method name, a bounded method, or a function that takes the object as first argument. '__call__' **kwargs The keyword arguments to pass to the method. {} Returns: Type Description Tuple[Any, ~A] A (output, tree) tuple containing the output of the method and the updated tree. Source code in treeo/mixins.py def mutable ( self : A , * args , method : tp . Union [ str , tp . Callable ] = \"__call__\" , ** kwargs , ) -> tp . Tuple [ tp . Any , A ]: \"\"\" Calls a method that contains stateful/mutable operations in an immutable fashion. `mutable` will let you perform stateful operations but all update will be performed other a new instance which is returned as the second output. Example: ```python @dataclass class MyTree(to.Tree, to.Immutable): total: int = to.node() def accumulate(self, inc) -> None: self.total += inc return self.total tree0 = MyTree(total=1) # increment by 10 total, tree = tree.mutable(10, method=\"accumulate\") assert total == 11 ``` Arguments: *args: The positional arguments to pass to the method. method: The method to call, can be a string with the method name, a bounded method, or a function that takes the object as first argument. **kwargs: The keyword arguments to pass to the method. Returns: A (output, tree) tuple containing the output of the method and the updated tree. \"\"\" unbounded_method : tp . Callable = ( getattr ( self . __class__ , method ) if isinstance ( method , str ) else method . __func__ if inspect . ismethod ( method ) else method ) return api . mutable ( unbounded_method )( self , * args , ** kwargs )","title":"mutable()"},{"location":"api/Immutable/#treeo.mixins.Immutable.replace","text":"Returns a copy of the Tree with the given fields specified in kwargs updated to the new values. Examples: @dataclass class MyTree ( to . Tree , to . Immutable ): x : int = to . node () tree = MyTree ( x = 1 ) # increment x by 1 tree = tree . replace ( x = tree . x + 1 ) Parameters: Name Type Description Default **kwargs The fields to update. {} Returns: Type Description ~A A new Tree with the updated fields. Source code in treeo/mixins.py def replace ( self : A , ** kwargs ) -> A : \"\"\" Returns a copy of the Tree with the given fields specified in `kwargs` updated to the new values. Example: ```python @dataclass class MyTree(to.Tree, to.Immutable): x: int = to.node() tree = MyTree(x=1) # increment x by 1 tree = tree.replace(x=tree.x + 1) ``` Arguments: **kwargs: The fields to update. Returns: A new Tree with the updated fields. \"\"\" tree = tree_m . copy ( self ) with tree_m . _make_mutable_single ( tree ): for key , value in kwargs . items (): setattr ( tree , key , value ) return tree","title":"replace()"},{"location":"api/ImmutableTree/","text":"treeo.ImmutableTree A Tree class that also inherits from Immutable .","title":"ImmutableTree"},{"location":"api/ImmutableTree/#treeoimmutabletree","text":"A Tree class that also inherits from Immutable .","title":"treeo.ImmutableTree"},{"location":"api/KindMixin/","text":"treeo.KindMixin","title":"KindMixin"},{"location":"api/KindMixin/#treeokindmixin","text":"","title":"treeo.KindMixin"},{"location":"api/MISSING/","text":"treeo.MISSING","title":"MISSING"},{"location":"api/MISSING/#treeomissing","text":"","title":"treeo.MISSING"},{"location":"api/Map/","text":"treeo.Map Mixin that adds a .map() method to the class. map ( self , f , * filters , * , inplace = False , flatten_mode = None , is_leaf = None ) map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"Map"},{"location":"api/Map/#treeomap","text":"Mixin that adds a .map() method to the class.","title":"treeo.Map"},{"location":"api/Map/#treeo.mixins.Map.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode , is_leaf = is_leaf , )","title":"map()"},{"location":"api/Merge/","text":"treeo.Merge Mixin that adds a .merge() method to the class. merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"Merge"},{"location":"api/Merge/#treeomerge","text":"Mixin that adds a .merge() method to the class.","title":"treeo.Merge"},{"location":"api/Merge/#treeo.mixins.Merge.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Missing/","text":"treeo.Missing","title":"Missing"},{"location":"api/Missing/#treeomissing","text":"","title":"treeo.Missing"},{"location":"api/NOTHING/","text":"treeo.NOTHING","title":"NOTHING"},{"location":"api/NOTHING/#treeonothing","text":"","title":"treeo.NOTHING"},{"location":"api/Nothing/","text":"treeo.Nothing","title":"Nothing"},{"location":"api/Nothing/#treeonothing","text":"","title":"treeo.Nothing"},{"location":"api/Opaque/","text":"treeo.Opaque","title":"Opaque"},{"location":"api/Opaque/#treeoopaque","text":"","title":"treeo.Opaque"},{"location":"api/OpaquePredicate/","text":"treeo.OpaquePredicate","title":"OpaquePredicate"},{"location":"api/OpaquePredicate/#treeoopaquepredicate","text":"","title":"treeo.OpaquePredicate"},{"location":"api/Repr/","text":"treeo.Repr Mixin that adds a __repr__ method to the class. __repr__ ( self ) special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"Repr"},{"location":"api/Repr/#treeorepr","text":"Mixin that adds a __repr__ method to the class.","title":"treeo.Repr"},{"location":"api/Repr/#treeo.mixins.Repr.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/ToDict/","text":"treeo.ToDict Mixin that adds a .to_dict() method to the class. to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"ToDict"},{"location":"api/ToDict/#treeotodict","text":"Mixin that adds a .to_dict() method to the class.","title":"treeo.ToDict"},{"location":"api/ToDict/#treeo.mixins.ToDict.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/ToString/","text":"treeo.ToString Mixin that adds a .to_string() method to the class. to_string ( self , * , private_fields = False , static_fields = True , color = False ) to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"ToString"},{"location":"api/ToString/#treeotostring","text":"Mixin that adds a .to_string() method to the class.","title":"treeo.ToString"},{"location":"api/ToString/#treeo.mixins.ToString.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Tree/","text":"treeo.Tree __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None cls . _mutable = False for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , ) check_metadata_updates ( self ) Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Tree"},{"location":"api/Tree/#treeotree","text":"","title":"treeo.Tree"},{"location":"api/Tree/#treeo.tree.Tree.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) # init class variables cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} cls . _subtrees = None cls . _mutable = False for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , )","title":"__init_subclass__()"},{"location":"api/Tree/#treeo.tree.Tree.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/TreeMeta/","text":"treeo.TreeMeta","title":"TreeMeta"},{"location":"api/TreeMeta/#treeotreemeta","text":"","title":"treeo.TreeMeta"},{"location":"api/add_field_info/","text":"treeo.add_field_info A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"add_field_info"},{"location":"api/add_field_info/#treeoadd_field_info","text":"A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"treeo.add_field_info"},{"location":"api/apply/","text":"treeo.apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. If a Tree is Immutable and inplace=True a RuntimeError could be raised if a field is mutated. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/tree.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False , _top_inplace : tp . Optional [ bool ] = None , ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. If a `Tree` is `Immutable` and `inplace=True` a `RuntimeError` could be raised if a field is mutated. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" if _top_inplace is None : _top_inplace = inplace rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True , _top_inplace = _top_inplace ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): if _top_inplace : f ( obj , * rest ) else : with _make_mutable_single ( obj ): f ( obj , * rest ) return obj","title":"apply"},{"location":"api/apply/#treeoapply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. If a Tree is Immutable and inplace=True a RuntimeError could be raised if a field is mutated. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/tree.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False , _top_inplace : tp . Optional [ bool ] = None , ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. If a `Tree` is `Immutable` and `inplace=True` a `RuntimeError` could be raised if a field is mutated. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" if _top_inplace is None : _top_inplace = inplace rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True , _top_inplace = _top_inplace ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): if _top_inplace : f ( obj , * rest ) else : with _make_mutable_single ( obj ): f ( obj , * rest ) return obj","title":"treeo.apply"},{"location":"api/compact/","text":"treeo.compact A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"compact"},{"location":"api/compact/#treeocompact","text":"A decorator that enable the definition of Tree subnodes at runtime. Source code in treeo/api.py def compact ( f ): \"\"\" A decorator that enable the definition of Tree subnodes at runtime. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ): with tree_m . _COMPACT_CONTEXT . compact ( f , tree ): return f ( tree , * args , ** kwargs ) wrapper . _treeo_compact = True return wrapper","title":"treeo.compact"},{"location":"api/copy/","text":"treeo.copy Returns a deep copy of the tree, almost equivalent to: jax . tree_map ( lambda x : x , self ) but will try to copy static nodes as well. Source code in treeo/tree.py def copy ( obj : A ) -> A : \"\"\" Returns a deep copy of the tree, almost equivalent to: ```python jax.tree_map(lambda x: x, self) ``` but will try to copy static nodes as well. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): return jax . tree_map ( lambda x : x , obj )","title":"copy"},{"location":"api/copy/#treeocopy","text":"Returns a deep copy of the tree, almost equivalent to: jax . tree_map ( lambda x : x , self ) but will try to copy static nodes as well. Source code in treeo/tree.py def copy ( obj : A ) -> A : \"\"\" Returns a deep copy of the tree, almost equivalent to: ```python jax.tree_map(lambda x: x, self) ``` but will try to copy static nodes as well. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): return jax . tree_map ( lambda x : x , obj )","title":"treeo.copy"},{"location":"api/field/","text":"treeo.field Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"field"},{"location":"api/field/#treeofield","text":"Source code in treeo/utils.py def field ( default : tp . Any = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , }, default_factory = default_factory if default_factory is not None else dataclasses . MISSING , init = init , repr = repr , hash = hash , compare = compare , )","title":"treeo.field"},{"location":"api/filter/","text":"treeo.filter The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : obj = utils . _safe_update_fields_from ( input_obj , obj ) return obj","title":"filter"},{"location":"api/filter/#treeofilter","text":"The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : obj = utils . _safe_update_fields_from ( input_obj , obj ) return obj","title":"treeo.filter"},{"location":"api/flatten_mode/","text":"treeo.flatten_mode A context manager that defines how Tree s are flattened. Options are: 'normal' : Fields are selected as nodes as declared in the class definition (default behavior). 'all_fields' : All fields are treated as nodes during flattening. 'no_fields' : All fields are treated as static, Tree s produce no leaves. None : Context is not changed, current flatten mode is preserved. Examples: @dataclass class MyTree ( Tree ): x : int # static y : int = to . node () tree = MyTree ( x = 1 , y = 3 ) jax . tree_map ( lambda x : x * 2 , tree ) # MyTree(x=1, y=6) with flatten_mode ( 'all_fields' ): jax . tree_map ( lambda x : x + 1 , tree ) # MyTree(x=2, y=6) Parameters: Name Type Description Default mode Union[treeo.tree.FlattenMode, str] The new flatten mode. required Source code in treeo/api.py @contextmanager def flatten_mode ( mode : tp . Optional [ tp . Union [ FlattenMode , str ]]): \"\"\" A context manager that defines how `Tree`s are flattened. Options are: * `'normal'`: Fields are selected as nodes as declared in the class definition (default behavior). * `'all_fields'`: All fields are treated as nodes during flattening. * `'no_fields'`: All fields are treated as static, `Tree`s produce no leaves. * `None`: Context is not changed, current flatten mode is preserved. Example: ```python @dataclass class MyTree(Tree): x: int # static y: int = to.node() tree = MyTree(x=1, y=3) jax.tree_map(lambda x: x * 2, tree) # MyTree(x=1, y=6) with flatten_mode('all_fields'): jax.tree_map(lambda x: x + 1, tree) # MyTree(x=2, y=6) ``` Arguments: mode: The new flatten mode. \"\"\" if mode is not None : if isinstance ( mode , str ): mode = FlattenMode ( mode ) with tree_m . _CONTEXT . update ( flatten_mode = mode ): yield else : yield","title":"flatten_mode"},{"location":"api/flatten_mode/#treeoflatten_mode","text":"A context manager that defines how Tree s are flattened. Options are: 'normal' : Fields are selected as nodes as declared in the class definition (default behavior). 'all_fields' : All fields are treated as nodes during flattening. 'no_fields' : All fields are treated as static, Tree s produce no leaves. None : Context is not changed, current flatten mode is preserved. Examples: @dataclass class MyTree ( Tree ): x : int # static y : int = to . node () tree = MyTree ( x = 1 , y = 3 ) jax . tree_map ( lambda x : x * 2 , tree ) # MyTree(x=1, y=6) with flatten_mode ( 'all_fields' ): jax . tree_map ( lambda x : x + 1 , tree ) # MyTree(x=2, y=6) Parameters: Name Type Description Default mode Union[treeo.tree.FlattenMode, str] The new flatten mode. required Source code in treeo/api.py @contextmanager def flatten_mode ( mode : tp . Optional [ tp . Union [ FlattenMode , str ]]): \"\"\" A context manager that defines how `Tree`s are flattened. Options are: * `'normal'`: Fields are selected as nodes as declared in the class definition (default behavior). * `'all_fields'`: All fields are treated as nodes during flattening. * `'no_fields'`: All fields are treated as static, `Tree`s produce no leaves. * `None`: Context is not changed, current flatten mode is preserved. Example: ```python @dataclass class MyTree(Tree): x: int # static y: int = to.node() tree = MyTree(x=1, y=3) jax.tree_map(lambda x: x * 2, tree) # MyTree(x=1, y=6) with flatten_mode('all_fields'): jax.tree_map(lambda x: x + 1, tree) # MyTree(x=2, y=6) ``` Arguments: mode: The new flatten mode. \"\"\" if mode is not None : if isinstance ( mode , str ): mode = FlattenMode ( mode ) with tree_m . _CONTEXT . update ( flatten_mode = mode ): yield else : yield","title":"treeo.flatten_mode"},{"location":"api/in_compact/","text":"treeo.in_compact Returns: Type Description bool True if current inside a function decorated with @compact . Source code in treeo/api.py def in_compact () -> bool : \"\"\" Returns: `True` if current inside a function decorated with `@compact`. \"\"\" return tree_m . _COMPACT_CONTEXT . in_compact","title":"in_compact"},{"location":"api/in_compact/#treeoin_compact","text":"Returns: Type Description bool True if current inside a function decorated with @compact . Source code in treeo/api.py def in_compact () -> bool : \"\"\" Returns: `True` if current inside a function decorated with `@compact`. \"\"\" return tree_m . _COMPACT_CONTEXT . in_compact","title":"treeo.in_compact"},{"location":"api/map/","text":"treeo.map Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None add_field_info Represent the leaves of the tree by a FieldInfo type. This enables values of the field such as required Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , field_info : tp . Optional [ bool ] = False , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. add_field_info: Represent the leaves of the tree by a `FieldInfo` type. This enables values of the field such as kind and value to be used within the `map` function. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj # Conditionally build map function with, or without, the leaf nodes' field info. if field_info : with add_field_info (): new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) else : new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : new_obj = utils . _safe_update_fields_from ( input_obj , new_obj ) return new_obj","title":"map"},{"location":"api/map/#treeomap","text":"Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None add_field_info Represent the leaves of the tree by a FieldInfo type. This enables values of the field such as required Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , is_leaf : tp . Callable [[ tp . Any ], bool ] = None , field_info : tp . Optional [ bool ] = False , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. add_field_info: Represent the leaves of the tree by a `FieldInfo` type. This enables values of the field such as kind and value to be used within the `map` function. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj # Conditionally build map function with, or without, the leaf nodes' field info. if field_info : with add_field_info (): new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) else : new_obj : A = jax . tree_map ( f , new_obj , is_leaf = is_leaf ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : new_obj = utils . _safe_update_fields_from ( input_obj , new_obj ) return new_obj","title":"treeo.map"},{"location":"api/merge/","text":"treeo.merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : obj = utils . _safe_update_fields_from ( input_obj , obj ) return obj","title":"merge"},{"location":"api/merge/#treeomerge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : obj = utils . _safe_update_fields_from ( input_obj , obj ) return obj","title":"treeo.merge"},{"location":"api/mutable/","text":"treeo.mutable A decorator that transforms a stateful function f that receives an Tree instance as a its first argument into a function that returns a tuple of the result and a Tree with the new state. This is useful for 2 reasons: * It transforms f into a pure function. * It allows Immutable Trees to perform inline field updates without getting RuntimeError s. Note that since the original object is not modified, Immutable instance remain in the end immutable. Examples: def accumulate_id ( tree : MyTree , x : int ) -> int : tree . n += x return x tree0 = MyTree ( n = 4 ) y , tree1 = mutable ( accumulate_id )( tree0 , 1 ) assert tree0 . n == 4 assert tree1 . n == 5 assert y == 1 Parameters: Name Type Description Default f Callable[..., ~A] The function to be transformed. required Returns: Type Description Callable[..., Tuple[~A, Any]] A function that returns a tuple of the result and a Tree with the new state. Source code in treeo/api.py def mutable ( f : tp . Callable [ ... , A ]) -> tp . Callable [ ... , tp . Tuple [ A , tp . Any ]]: \"\"\" A decorator that transforms a stateful function `f` that receives an Tree instance as a its first argument into a function that returns a tuple of the result and a Tree with the new state. This is useful for 2 reasons: * It transforms `f` into a pure function. * It allows `Immutable` Trees to perform inline field updates without getting `RuntimeError`s. Note that since the original object is not modified, `Immutable` instance remain in the end immutable. Example: ```python def accumulate_id(tree: MyTree, x: int) -> int: tree.n += x return x tree0 = MyTree(n=4) y, tree1 = mutable(accumulate_id)(tree0, 1) assert tree0.n == 4 assert tree1.n == 5 assert y == 1 ``` Arguments: f: The function to be transformed. Returns: A function that returns a tuple of the result and a Tree with the new state. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ) -> tp . Tuple [ A , tp . Any ]: tree = tree_m . copy ( tree ) with tree_m . _make_mutable ( tree ): output = f ( tree , * args , ** kwargs ) return output , tree return wrapper","title":"mutable"},{"location":"api/mutable/#treeomutable","text":"A decorator that transforms a stateful function f that receives an Tree instance as a its first argument into a function that returns a tuple of the result and a Tree with the new state. This is useful for 2 reasons: * It transforms f into a pure function. * It allows Immutable Trees to perform inline field updates without getting RuntimeError s. Note that since the original object is not modified, Immutable instance remain in the end immutable. Examples: def accumulate_id ( tree : MyTree , x : int ) -> int : tree . n += x return x tree0 = MyTree ( n = 4 ) y , tree1 = mutable ( accumulate_id )( tree0 , 1 ) assert tree0 . n == 4 assert tree1 . n == 5 assert y == 1 Parameters: Name Type Description Default f Callable[..., ~A] The function to be transformed. required Returns: Type Description Callable[..., Tuple[~A, Any]] A function that returns a tuple of the result and a Tree with the new state. Source code in treeo/api.py def mutable ( f : tp . Callable [ ... , A ]) -> tp . Callable [ ... , tp . Tuple [ A , tp . Any ]]: \"\"\" A decorator that transforms a stateful function `f` that receives an Tree instance as a its first argument into a function that returns a tuple of the result and a Tree with the new state. This is useful for 2 reasons: * It transforms `f` into a pure function. * It allows `Immutable` Trees to perform inline field updates without getting `RuntimeError`s. Note that since the original object is not modified, `Immutable` instance remain in the end immutable. Example: ```python def accumulate_id(tree: MyTree, x: int) -> int: tree.n += x return x tree0 = MyTree(n=4) y, tree1 = mutable(accumulate_id)(tree0, 1) assert tree0.n == 4 assert tree1.n == 5 assert y == 1 ``` Arguments: f: The function to be transformed. Returns: A function that returns a tuple of the result and a Tree with the new state. \"\"\" @functools . wraps ( f ) def wrapper ( tree , * args , ** kwargs ) -> tp . Tuple [ A , tp . Any ]: tree = tree_m . copy ( tree ) with tree_m . _make_mutable ( tree ): output = f ( tree , * args , ** kwargs ) return output , tree return wrapper","title":"treeo.mutable"},{"location":"api/node/","text":"treeo.node Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"node"},{"location":"api/node/#treeonode","text":"Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treeo.node"},{"location":"api/static/","text":"treeo.static Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"static"},{"location":"api/static/#treeostatic","text":"Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory : tp . Optional [ tp . Callable [[], tp . Any ]] = None , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : tp . Union [ bool , OpaquePredicate ] = False , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , )","title":"treeo.static"},{"location":"api/to_dict/","text":"treeo.to_dict Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = tree_m . apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"to_dict"},{"location":"api/to_dict/#treeoto_dict","text":"Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = tree_m . apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"treeo.to_dict"},{"location":"api/to_string/","text":"treeo.to_string Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"to_string"},{"location":"api/to_string/#treeoto_string","text":"Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"treeo.to_string"},{"location":"user-guide/compact/","text":"Compact Treeo's compact decorator and Compact mixin allow the initialization of fields and the definition of Tree nodes during a function call. compact enables a simpler syntax for Trees who's computation structure follows the Tree's structure. For example, if you have Trees with the following behavior: import Treeo as to class Child ( to . Tree ): some_node : float = to . node () def __call__ ( self , x ): ... return x class Parent ( to . Tree ): def __init__ ( self ): self . child1 = Child ( 10 ) self . child2 = Child ( 20 ) self . child3 = Child ( 30 ) def __call__ ( self , x ): x = self . child1 ( x ) x = self . child2 ( x ) x = self . child3 ( x ) return x Notice how you have to specify/use the same fields in __init__ and __call__ . To reduce the amount of boilerplate you can use the compact decorator: class Parent ( to . Tree ): @to . compact def __call__ ( self , x ): x = Child ( 10 )( x ) x = Child ( 20 )( x ) x = Child ( 30 )( x ) return x While it seems that Child Trees are been created on every call, compact will keep track of the Trees created during the first call, assign them as fields to Parent , and reuse them on subsequent calls; their constructors will be called only once. Warning You cannot conditionally construct Trees on a compact method unless that conditional doesn't change during the Tree's lifespan. Adding the following to the previous example will cause trouble: if x . shape [ 0 ] > 10 : x = Child ( 10 )( x ) The number and order in which the sub-Trees are defined inside compact should always be the same. Naming The names of the created Trees are stored in order of creation in ._subtrees , the name of the field will be defined as follows: If the Tree has a name attribute, it will be used as the name of the field. Else if it has a __name__ attribute, it will be used. Else a snake_case version of the Tree's class name will be used. If a field with the same name already exists, a number will be appended to the name. The previous example will result in the following fields: child , child2 , child3 . Compact Mixin With the Compact mixin you can add the get_field method and the first_run property to a Tree subclass, these methods provide mechanisms to initialize fields at runtime potentially based on some properties of the input. As an example lets code a Linear Tree that does shape inference for its w and b parameters: class Linear ( to . Tree , to . Compact ): w : float = to . node () b : float = to . node () def __init__ ( self , dout , key ): self . dout = dout self . key = key @to . compact def __call__ ( self , x ): din = x . shape [ - 1 ] w = self . get_field ( \"w\" , lambda : jax . random . uniform ( self . key , [ din , self . dout ])) b = self . get_field ( \"b\" , lambda : jnp . zeros ( shape = [ self . dout ])) return jnp . dot ( x , w ) + b get_field will initialize the w and b fields on the first run and fetch their values on subsequent runs. You can also use the first_run property and manually initialize the fields: class Linear ( to . Tree , to . Compact ): w : float = to . node () b : float = to . node () def __init__ ( self , dout , key ): self . dout = dout self . key = key @to . compact def __call__ ( self , x ): if self . first_run : din = x . shape [ - 1 ] self . w = jax . random . uniform ( self . key , [ din , self . dout ]) self . b = jnp . zeros ( shape = [ self . dout ]) return jnp . dot ( x , self . w ) + self . b This is useful if you want to perform more complex initialization procedures.","title":"Compact Trees"},{"location":"user-guide/compact/#compact","text":"Treeo's compact decorator and Compact mixin allow the initialization of fields and the definition of Tree nodes during a function call. compact enables a simpler syntax for Trees who's computation structure follows the Tree's structure. For example, if you have Trees with the following behavior: import Treeo as to class Child ( to . Tree ): some_node : float = to . node () def __call__ ( self , x ): ... return x class Parent ( to . Tree ): def __init__ ( self ): self . child1 = Child ( 10 ) self . child2 = Child ( 20 ) self . child3 = Child ( 30 ) def __call__ ( self , x ): x = self . child1 ( x ) x = self . child2 ( x ) x = self . child3 ( x ) return x Notice how you have to specify/use the same fields in __init__ and __call__ . To reduce the amount of boilerplate you can use the compact decorator: class Parent ( to . Tree ): @to . compact def __call__ ( self , x ): x = Child ( 10 )( x ) x = Child ( 20 )( x ) x = Child ( 30 )( x ) return x While it seems that Child Trees are been created on every call, compact will keep track of the Trees created during the first call, assign them as fields to Parent , and reuse them on subsequent calls; their constructors will be called only once. Warning You cannot conditionally construct Trees on a compact method unless that conditional doesn't change during the Tree's lifespan. Adding the following to the previous example will cause trouble: if x . shape [ 0 ] > 10 : x = Child ( 10 )( x ) The number and order in which the sub-Trees are defined inside compact should always be the same.","title":"Compact"},{"location":"user-guide/compact/#naming","text":"The names of the created Trees are stored in order of creation in ._subtrees , the name of the field will be defined as follows: If the Tree has a name attribute, it will be used as the name of the field. Else if it has a __name__ attribute, it will be used. Else a snake_case version of the Tree's class name will be used. If a field with the same name already exists, a number will be appended to the name. The previous example will result in the following fields: child , child2 , child3 .","title":"Naming"},{"location":"user-guide/compact/#compact-mixin","text":"With the Compact mixin you can add the get_field method and the first_run property to a Tree subclass, these methods provide mechanisms to initialize fields at runtime potentially based on some properties of the input. As an example lets code a Linear Tree that does shape inference for its w and b parameters: class Linear ( to . Tree , to . Compact ): w : float = to . node () b : float = to . node () def __init__ ( self , dout , key ): self . dout = dout self . key = key @to . compact def __call__ ( self , x ): din = x . shape [ - 1 ] w = self . get_field ( \"w\" , lambda : jax . random . uniform ( self . key , [ din , self . dout ])) b = self . get_field ( \"b\" , lambda : jnp . zeros ( shape = [ self . dout ])) return jnp . dot ( x , w ) + b get_field will initialize the w and b fields on the first run and fetch their values on subsequent runs. You can also use the first_run property and manually initialize the fields: class Linear ( to . Tree , to . Compact ): w : float = to . node () b : float = to . node () def __init__ ( self , dout , key ): self . dout = dout self . key = key @to . compact def __call__ ( self , x ): if self . first_run : din = x . shape [ - 1 ] self . w = jax . random . uniform ( self . key , [ din , self . dout ]) self . b = jnp . zeros ( shape = [ self . dout ]) return jnp . dot ( x , self . w ) + self . b This is useful if you want to perform more complex initialization procedures.","title":"Compact Mixin"},{"location":"user-guide/defining-fields/","text":"Tree fields are divided into two categories: node fields: they are considered as part of the pytree, JAX functions such as tree_map will operate over them. static fields: they are part of the PyTreeDef , JAX functions will not operate over them, but JAX is still aware of them, e.g. JAX will recompile jitted functions is case these fields change. import treeo as to @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John') Since field is just a wrapper over dataclasses.field that adds the node and kind arguments you can use all dataclass features. However, dataclasses are orthogonal to Treeo, this means that you can naturally use non-dataclass classes: class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) def __init__ ( self , height : float , name : str ): self . height = height self . name = name person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John')","title":"Defining Fields"},{"location":"user-guide/field-kinds/","text":"Kinds are associated types that give semantic meaning to a field (what it represents). A kind is just a type you pass to field via its kind argument. Kinds are mostly useful as metadata filtering via treeo.filter . For example, here is a possible definition for a BatchNorm module using kinds: import treeo as to class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) bias : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) var : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... Now with this definition you use filter to select specific kind of fields: model = BatchNorm ( ... ) # BatchNorm(scale=array(...), bias=array(...), mean=Nothing, var=Nothing) params = to . filter ( model , Parameter ) # filter by kind # BatchNorm(scale=Nothing, bias=Nothing, mean=array(...), var=array(...)) batch_stats = to . filter ( model , BatchStat ) This can be very useful to operate over specific subsets of your Trees e.g. sync subset of parameters across devices in a distributed computation.","title":"Field Kinds"},{"location":"user-guide/field-metadata/","text":"All metadata you set either with to.field or added by Treeo by default will be available in the field_metadata: Mapping[str, FieldMetadata] property. @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) mike = Person ( height = 1.5 , name = 'Mike' ) # no quite true, but you get the idea assert mike . field_metadata == { 'height' : FieldMetadata ( node = True , kind = NoneType , opaque = False , ), 'name' : FieldMetadata ( node = False , kind = None , opaque = True , ) } Changing field metadata If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Field Metadata"},{"location":"user-guide/field-metadata/#changing-field-metadata","text":"If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Changing field metadata"},{"location":"user-guide/intro/","text":"User Guide Before we start it would be useful to define some terminology that will be used throughout the documentation. Terminology Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"User Guide"},{"location":"user-guide/intro/#user-guide","text":"Before we start it would be useful to define some terminology that will be used throughout the documentation.","title":"User Guide"},{"location":"user-guide/intro/#terminology","text":"Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"Terminology"},{"location":"user-guide/node-policy/","text":"If a field is not marked with to.field the following policy will be applied when determining whether a field is a node or not: If the field is annotated with a Tree subtype or a generic containing a Tree subtype e.g. List[to.Tree] , the field is considered a node . If the runtime value of the field is a to.Tree instance, the field is considered a node and the Tree 's metadata will be updated to reflect this. If none of the above apply, the field is considered a static field. import treeo as to class Agent ( to . Tree ): ... class Game ( to . Tree ): player : Agent # node cpus : List [ Agent ] # node max_cpus : int # static def __init__ ( self , ... ): ... self . boss = Agent ( ... ) # runtime node Note: the kind of all fields that are not explicitly declarated is set to NoneType .","title":"Node policy"},{"location":"user-guide/non-hashable-static-fields/","text":"Static fields are required to be hashable by JAX, so what happens if you want to have a static field that contains a non-hashable value like a numpy or jax array? For example: import treeo as to @dataclass class MyTree ( to . Tree ): table : np . ndarray One solution is to make that field opaque , this will work as long as you don't need jit and friends to reach to changes to its value content for recompiling. If you do, you can instead use the to.Hashable(value) class to wrap around it like this: @dataclass class MyTree ( to . Tree ): table : to . Hashable [ np . ndarray ] The hash from Hashable will only depend on object identity but not on the actual value , therefore you should treat it as immutable, if you want to update its content you should create a new Hashable instance: table = to . Hasable ( np . ones (( 10 , 10 ))) tree = MyTree ( table ) @jax . jit def do_something ( tree : MyTree ): table_value = tree . table . value # use Hashable.value ... tree = do_something ( tree ) # compiles tree = do_something ( tree ) # uses cache # update table module . table = to . Hashable ( np . zeros (( 10 , 10 ))) tree = do_something ( tree ) # recompiles Warning : If you are somehow able to mutate Hashable.value directly JAX won't know about this and jit won't recompile.","title":"Non-hashable static fields"},{"location":"user-guide/opaque-static-fields/","text":"When the value of a static field changes jit and friends will recompile to reflect posible changes in the computation logic. While this is good quality in many cases, sometimes certain fields are just there for metadata and should not part of the actual computation. For example, name in the Person example above will probably not affect the logic yet in this example it will force recompilation: @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # re-compiles \ud83d\ude41 To avoid this, you can mark a field as opaque : @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # cached! \ud83e\udd29 opaque will \"hide\" the value content of the field from JAX, changes will only be detected if the type of an opaque field changes or, in case its an array-like type, if its shape or dtype changes. opaque predicates If you want to define you on policy on how opaque fields are handled, you can use pass a Callable[[to.Opaque, Any], bool] function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = same_length , )","title":"Opaque static fields"},{"location":"user-guide/opaque-static-fields/#opaque-predicates","text":"If you want to define you on policy on how opaque fields are handled, you can use pass a Callable[[to.Opaque, Any], bool] function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = same_length , )","title":"opaque predicates"},{"location":"user-guide/state-management/","text":"Treeo takes a \"direct\" approach to state management, i.e., state is updated in-place by the Tree whenever it needs to. For example, this module will calculate the running average of its input: @dataclass class Average ( to . Tree ): count : State [ jnp . ndarray ] = jnp . array ( 0 ) total : State [ jnp . ndarray ] = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count What is the catch? State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . merge ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"State Management"},{"location":"user-guide/state-management/#what-is-the-catch","text":"State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . merge ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"What is the catch?"},{"location":"user-guide/sugar/","text":"For pedagogical reason, field has been used throught the documentation to reinforce the concepts, however, Treeo has a couple of shortcuts to make it easier and more understandable to define Trees. normal shortcut to.field(node=True) to.node() to.field(node=False) to.static() to.field(node=True, kind=Kind) Kind.node() to.field(node=False, kind=Kind) Kind.static() Based on this, you can take the following code class Parameter : pass class Child ( to . Tree ): a : float = to . field ( node = True ) b : str = to . field ( node = False ) b : float = to . field ( node = True , kind = Parameter ) d : float = to . field ( node = False , kind = Parameter ) class Parent ( to . Tree ): child1 : Child = to . field ( node = True ) child2 : Child = to . field ( node = False ) rest : List [ Child ] = to . field ( node = True ) and simplify it to: class Parameter ( to . KindMixin ): pass class Child ( to . Tree ): a : float = to . node () b : str # = to.static(), inferred b : float = Parameter . node () d : float = Parameter . static () class Parent ( to . Tree ): child1 : Child # = to.node(), inferred child2 : Child = to . static () rest : List [ Child ] # = to.node(), inferred The to.KindMixin provides the .field() , .node() , and .static() methods to subtypes, in this case the Parameter class.","title":"Sugar \ud83c\udf6c"},{"location":"user-guide/api/apply/","text":"Apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. For example, if you have a setup like this: import treeo as to class Child ( to . Tree ): training : bool = to . field ( default = True , node = False ) value : float = to . field ( node = True ) ... class Parent ( to . Tree ): training : bool = to . field ( default = True , node = False ) left : Child righ : Child ... tree = Parent ( ... ) And then want to update all .training fields to False you can do this: def set_training_false ( tree ): if isinstance ( tree , ( Parent , Child )): tree . training = False tree = to . apply ( set_training_false , tree ) Here tree is iternally copied so you can mutate is safely during apply without affecting the original object, however if inplace is True the original object will be mutated and returned.","title":"Apply"},{"location":"user-guide/api/apply/#apply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. For example, if you have a setup like this: import treeo as to class Child ( to . Tree ): training : bool = to . field ( default = True , node = False ) value : float = to . field ( node = True ) ... class Parent ( to . Tree ): training : bool = to . field ( default = True , node = False ) left : Child righ : Child ... tree = Parent ( ... ) And then want to update all .training fields to False you can do this: def set_training_false ( tree ): if isinstance ( tree , ( Parent , Child )): tree . training = False tree = to . apply ( set_training_false , tree ) Here tree is iternally copied so you can mutate is safely during apply without affecting the original object, however if inplace is True the original object will be mutated and returned.","title":"Apply"},{"location":"user-guide/api/copy/","text":"Copy Returns a deep copy of the tree, almost equivalent to: jax . tree_map ( lambda x : x , self ) but will try to copy static nodes as well.","title":"Copy"},{"location":"user-guide/api/copy/#copy","text":"Returns a deep copy of the tree, almost equivalent to: jax . tree_map ( lambda x : x , self ) but will try to copy static nodes as well.","title":"Copy"},{"location":"user-guide/api/filter/","text":"Filter The filter function allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: jax . tree_map ( lambda x : - x , to . filter ( tree , Parameter )) # MyTree(a=-1, b=Nothing) jax . tree_map ( lambda x : - x , to . filter ( tree , BatchStat )) # MyTree(a=Nothing, b=-2) filter predicates If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np .2 , jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.2, jnp.array([3.0, 4.0])] multiple filters You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) inplace If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Filter"},{"location":"user-guide/api/filter/#filter","text":"The filter function allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: jax . tree_map ( lambda x : - x , to . filter ( tree , Parameter )) # MyTree(a=-1, b=Nothing) jax . tree_map ( lambda x : - x , to . filter ( tree , BatchStat )) # MyTree(a=Nothing, b=-2)","title":"Filter"},{"location":"user-guide/api/filter/#filter-predicates","text":"If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np .2 , jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.2, jnp.array([3.0, 4.0])]","title":"filter predicates"},{"location":"user-guide/api/filter/#multiple-filters","text":"You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing)","title":"multiple filters"},{"location":"user-guide/api/filter/#inplace","text":"If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"inplace"},{"location":"user-guide/api/map/","text":"Map Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. Further, property of the field's kind type can be used within map by setting the field_info argument as True. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) We could also apply a custom function to those fields with the Parameter type def parameter_fn ( field ): return f + 1 to . map ( parameter_fn , tree , Parameter , field_info = True ) # MyTree(a=2, b=2) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/map/#map","text":"Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. Further, property of the field's kind type can be used within map by setting the field_info argument as True. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) We could also apply a custom function to those fields with the Parameter type def parameter_fn ( field ): return f + 1 to . map ( parameter_fn , tree , Parameter , field_info = True ) # MyTree(a=2, b=2) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/merge/","text":"Merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) merge ( t1 , t2 ) # MyTree(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be merged. If flatten_mode=\"normal\" is set then static fields won't be merged and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Trees the following equivalence holds: merge(m1, m2, m3) = merge(m1, merge(m2, m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) merge ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"},{"location":"user-guide/api/merge/#merge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) merge ( t1 , t2 ) # MyTree(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be merged. If flatten_mode=\"normal\" is set then static fields won't be merged and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Trees the following equivalence holds: merge(m1, m2, m3) = merge(m1, merge(m2, m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) merge ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"}]}