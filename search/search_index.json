{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Treeo A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo was originally extracted from the core of Treex and (although the author was not aware of this at the time) shares a lot in common with flax.struct . Treeo has nothing in particular to do with Deep Learning, but some of the examples are motivated by it. Documentation | Guide Installation Install using pip: pip install treeo Basics At its core Treeo focuses on 2 things: Tooling for defining pytree structures via field metadata. A set of functions for manipulating pytree structures that leverage the field metadata. As part of the field metadata Treeo introduce the concept of a kind which enables a powerful filtering mechanism. Fields To define node fields for a custom Pytree, Treeo uses the field function which is a wrapper around dataclasses.field : import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! Using this information Treeo specifies a Pytree you can use with various jax functions. p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John') Kinds Kinds allow you to imbue semantic information into your Pytree, this is critcal for filtering operations where cannot know the purpose of a leaf based on its type. Using the kind argument of field and Treeo's filter function you select only the nodes you want to keep: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) def loss_fn ( params , model , ... ): # merge params back into model model = to . update ( model , params ) ... model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... ) Examples A simple Tree from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += character . velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 ) Stateful Trees from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree Full Example - Linear Regression import matplotlib.pyplot as plt import numpy as np import treeo as to class Parameter : pass class Linear ( to . Tree ): din : int # static dout : int # static w : jnp . ndarray = to . field ( node = True , kind = Parameter ) b : jnp . ndarray = to . field ( node = True , kind = Parameter ) def __init__ ( self , din , dout , key ): self . din = din self . dout = dout self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Getting Started"},{"location":"#treeo","text":"A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo was originally extracted from the core of Treex and (although the author was not aware of this at the time) shares a lot in common with flax.struct . Treeo has nothing in particular to do with Deep Learning, but some of the examples are motivated by it. Documentation | Guide","title":"Treeo"},{"location":"#installation","text":"Install using pip: pip install treeo","title":"Installation"},{"location":"#basics","text":"At its core Treeo focuses on 2 things: Tooling for defining pytree structures via field metadata. A set of functions for manipulating pytree structures that leverage the field metadata. As part of the field metadata Treeo introduce the concept of a kind which enables a powerful filtering mechanism.","title":"Basics"},{"location":"#fields","text":"To define node fields for a custom Pytree, Treeo uses the field function which is a wrapper around dataclasses.field : import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! Using this information Treeo specifies a Pytree you can use with various jax functions. p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John')","title":"Fields"},{"location":"#kinds","text":"Kinds allow you to imbue semantic information into your Pytree, this is critcal for filtering operations where cannot know the purpose of a leaf based on its type. Using the kind argument of field and Treeo's filter function you select only the nodes you want to keep: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) def loss_fn ( params , model , ... ): # merge params back into model model = to . update ( model , params ) ... model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... )","title":"Kinds"},{"location":"#examples","text":"","title":"Examples"},{"location":"#a-simple-tree","text":"from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += character . velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 )","title":"A simple Tree"},{"location":"#stateful-trees","text":"from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree","title":"Stateful Trees"},{"location":"#full-example-linear-regression","text":"import matplotlib.pyplot as plt import numpy as np import treeo as to class Parameter : pass class Linear ( to . Tree ): din : int # static dout : int # static w : jnp . ndarray = to . field ( node = True , kind = Parameter ) b : jnp . ndarray = to . field ( node = True , kind = Parameter ) def __init__ ( self , din , dout , key ): self . din = din self . dout = dout self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Full Example - Linear Regression"},{"location":"api/ArrayLike/","text":"treeo.ArrayLike __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/utils.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/utils.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/utils.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"ArrayLike"},{"location":"api/ArrayLike/#treeoarraylike","text":"","title":"treeo.ArrayLike"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__","text":"","title":"__class__"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/utils.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/utils.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/utils.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/FieldInfo/","text":"treeo.FieldInfo","title":"FieldInfo"},{"location":"api/FieldInfo/#treeofieldinfo","text":"","title":"treeo.FieldInfo"},{"location":"api/FieldMetadata/","text":"treeo.FieldMetadata FieldMetadata(node: bool, kind: type, opaque: bool, opaque_is_equal: Union[Callable[[treeo.utils.Opaque, Any], bool], NoneType])","title":"FieldMetadata"},{"location":"api/FieldMetadata/#treeofieldmetadata","text":"FieldMetadata(node: bool, kind: type, opaque: bool, opaque_is_equal: Union[Callable[[treeo.utils.Opaque, Any], bool], NoneType])","title":"treeo.FieldMetadata"},{"location":"api/Hashable/","text":"treeo.Hashable A hashable immutable wrapper around non-hashable values","title":"Hashable"},{"location":"api/Hashable/#treeohashable","text":"A hashable immutable wrapper around non-hashable values","title":"treeo.Hashable"},{"location":"api/KindMixin/","text":"treeo.KindMixin","title":"KindMixin"},{"location":"api/KindMixin/#treeokindmixin","text":"","title":"treeo.KindMixin"},{"location":"api/MISSING/","text":"treeo.MISSING","title":"MISSING"},{"location":"api/MISSING/#treeomissing","text":"","title":"treeo.MISSING"},{"location":"api/Missing/","text":"treeo.Missing","title":"Missing"},{"location":"api/Missing/#treeomissing","text":"","title":"treeo.Missing"},{"location":"api/NOTHING/","text":"treeo.NOTHING","title":"NOTHING"},{"location":"api/NOTHING/#treeonothing","text":"","title":"treeo.NOTHING"},{"location":"api/Nothing/","text":"treeo.Nothing","title":"Nothing"},{"location":"api/Nothing/#treeonothing","text":"","title":"treeo.Nothing"},{"location":"api/Opaque/","text":"treeo.Opaque","title":"Opaque"},{"location":"api/Opaque/#treeoopaque","text":"","title":"treeo.Opaque"},{"location":"api/Tree/","text":"treeo.Tree __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], opaque_is_equal = value . metadata [ \"opaque_is_equal\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , opaque_is_equal = None , )","title":"Tree"},{"location":"api/Tree/#treeotree","text":"","title":"treeo.Tree"},{"location":"api/Tree/#treeo.tree.Tree.__class__","text":"","title":"__class__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], opaque_is_equal = value . metadata [ \"opaque_is_equal\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , opaque_is_equal = None , )","title":"__init_subclass__()"},{"location":"api/TreeMeta/","text":"treeo.TreeMeta __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"TreeMeta"},{"location":"api/TreeMeta/#treeotreemeta","text":"","title":"treeo.TreeMeta"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/add_field_info/","text":"treeo.add_field_info A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/tree.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with _CONTEXT . update ( add_field_info = True ): yield","title":"add_field_info"},{"location":"api/add_field_info/#treeoadd_field_info","text":"A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/tree.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with _CONTEXT . update ( add_field_info = True ): yield","title":"treeo.add_field_info"},{"location":"api/apply/","text":"treeo.apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/tree.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"apply"},{"location":"api/apply/#treeoapply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/tree.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"treeo.apply"},{"location":"api/field/","text":"treeo.field Source code in treeo/utils.py def field ( default = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , \"opaque_is_equal\" : opaque_is_equal , }, default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , )","title":"field"},{"location":"api/field/#treeofield","text":"Source code in treeo/utils.py def field ( default = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , \"opaque_is_equal\" : opaque_is_equal , }, default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , )","title":"treeo.field"},{"location":"api/filter/","text":"treeo.filter Returns a new tree with any leaf that does not match all the given filter set to Nothing . Filters are callable of type: ( FieldInfo ) -> bool You can also pass types to filter by, these are know as kind filters and, for a type t , are roughly equivalent to: def kind_filter ( field : FieldInfo ) -> bool : return issubclass ( field . kind , t ) Examples: class Parameter : pass class BatchStat : pass @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( 1 , 2 ) to . filter ( tree , lambda field : issubclass ( field . kind , Parameter )) # MyTree(a=1, b=Nothing) to . filter ( tree , lambda field : issubclass ( field . kind , BatchStat )) # MyTree(a=Nothing, b=2) The previous can be more compactly expressed using kind filters as: tree = MyTree ( 1 , 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/tree.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Returns a new tree with any leaf that does not match all the given filter set to `Nothing`. Filters are callable of type: ```python (FieldInfo) -> bool ``` You can also pass types to filter by, these are know as `kind` filters and, for a type `t`, are roughly equivalent to: ```python def kind_filter(field: FieldInfo) -> bool: return issubclass(field.kind, t) ``` Example: ```python class Parameter: pass class BatchStat: pass @dataclass class MyTree(to.Tree): a: int = to.field(node=True, kind=Parameter) b: int = to.field(node=True, kind=BatchStat) tree = MyTree(1, 2) to.filter(tree, lambda field: issubclass(field.kind, Parameter)) # MyTree(a=1, b=Nothing) to.filter(tree, lambda field: issubclass(field.kind, BatchStat)) # MyTree(a=Nothing, b=2) ``` The previous can be more compactly expressed using `kind` filters as: ```python tree = MyTree(1, 2) to.filter(tree, Parameter) # MyTree(a=1, b=Nothing) to.filter(tree, BatchStat) # MyTree(a=Nothing, b=2) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with _Context ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"filter"},{"location":"api/filter/#treeofilter","text":"Returns a new tree with any leaf that does not match all the given filter set to Nothing . Filters are callable of type: ( FieldInfo ) -> bool You can also pass types to filter by, these are know as kind filters and, for a type t , are roughly equivalent to: def kind_filter ( field : FieldInfo ) -> bool : return issubclass ( field . kind , t ) Examples: class Parameter : pass class BatchStat : pass @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( 1 , 2 ) to . filter ( tree , lambda field : issubclass ( field . kind , Parameter )) # MyTree(a=1, b=Nothing) to . filter ( tree , lambda field : issubclass ( field . kind , BatchStat )) # MyTree(a=Nothing, b=2) The previous can be more compactly expressed using kind filters as: tree = MyTree ( 1 , 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/tree.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Returns a new tree with any leaf that does not match all the given filter set to `Nothing`. Filters are callable of type: ```python (FieldInfo) -> bool ``` You can also pass types to filter by, these are know as `kind` filters and, for a type `t`, are roughly equivalent to: ```python def kind_filter(field: FieldInfo) -> bool: return issubclass(field.kind, t) ``` Example: ```python class Parameter: pass class BatchStat: pass @dataclass class MyTree(to.Tree): a: int = to.field(node=True, kind=Parameter) b: int = to.field(node=True, kind=BatchStat) tree = MyTree(1, 2) to.filter(tree, lambda field: issubclass(field.kind, Parameter)) # MyTree(a=1, b=Nothing) to.filter(tree, lambda field: issubclass(field.kind, BatchStat)) # MyTree(a=Nothing, b=2) ``` The previous can be more compactly expressed using `kind` filters as: ```python tree = MyTree(1, 2) to.filter(tree, Parameter) # MyTree(a=1, b=Nothing) to.filter(tree, BatchStat) # MyTree(a=Nothing, b=2) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with _Context ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treeo.filter"},{"location":"api/map/","text":"treeo.map Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Examples: class Parameter : pass class BatchStat : pass @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( 1 , 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/tree.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`. If `filters` are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: ```python class Parameter: pass class BatchStat: pass @dataclass class MyTree(to.Tree): a: int = to.field(node=True, kind=Parameter) b: int = to.field(node=True, kind=BatchStat) tree = MyTree(1, 2) to.map(lambda _: 0, tree, BatchStat) # MyTree(a=1, b=0) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj ) if has_filters : new_obj = update ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"map"},{"location":"api/map/#treeomap","text":"Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Examples: class Parameter : pass class BatchStat : pass @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( 1 , 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/tree.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`. If `filters` are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: ```python class Parameter: pass class BatchStat: pass @dataclass class MyTree(to.Tree): a: int = to.field(node=True, kind=Parameter) b: int = to.field(node=True, kind=BatchStat) tree = MyTree(1, 2) to.map(lambda _: 0, tree, BatchStat) # MyTree(a=1, b=0) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj ) if has_filters : new_obj = update ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"treeo.map"},{"location":"api/node/","text":"treeo.node Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"node"},{"location":"api/node/#treeonode","text":"Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"treeo.node"},{"location":"api/static/","text":"treeo.static Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"static"},{"location":"api/static/#treeostatic","text":"Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"treeo.static"},{"location":"api/update/","text":"treeo.update Creates a new Tree with the same structure, but its values updated based on the values from the incoming Trees. Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf in reverse order. If no flatten_mode() context manager is active, and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set, the output will have the exact same static components as the first input ( obj ). Examples: t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) update ( t1 , t2 ) # MyTree(x=1, y=2, z=4) When using update with multiple Trees the following equivalence holds: update(m1, m2, m3) = update(m1, update(m2, m3)) If you want to update the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) update ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the update process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches. Parameters: Name Type Description Default obj ~A Main pytree to update. required other ~A The pytree first to get the values to update from. required *rest ~A Additional pytree to perform the update in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/tree.py def update ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure, but its values updated based on the values from the incoming Trees. Updates are performed using the following rules: * For a list of equivalent leaves `l1, l2, ..., ln`, it returns the first non-`Nothing` leaf in reverse order. * If no `flatten_mode()` context manager is active, and `flatten_mode` is not given, all fields will be updated. * If `flatten_mode=\"normal\"` is set, the output will have the exact same static components as the first input (`obj`). Example: ```python t1 = MyTree(x=Nothing, y=2, z=3) t2 = MyTree(x=1, y=Nothing, z=4) update(t1, t2) # MyTree(x=1, y=2, z=4) ``` When using `update` with multiple Trees the following equivalence holds: ``` update(m1, m2, m3) = update(m1, update(m2, m3)) ``` If you want to update the current module instead of creating a new one use `inplace=True`. This is useful when applying transformation inside a method where reassigning `self` is not possible: ```python def double_params(self): # this is not doing what you expect self = jax.tree_map(lambda x: 2 * x, self) ``` Instead do this: ```python def double_params(self): doubled = jax.tree_map(lambda x: 2 * x, self) update(self, doubled, inplace=True) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. If `ignore_static` is `True`, static fields (according to the flattening mode) will be bypassed during the update process, the final output will have the same static components as the first input (`obj`). This strategy is a bit less safe in general as it will flatten all trees using `jax.tree_leaves` instead of `PyTreeDef.flatten_up_to`, this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches. Arguments: obj: Main pytree to update. other: The pytree first to get the values to update from. *rest: Additional pytree to perform the update in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"update"},{"location":"api/update/#treeoupdate","text":"Creates a new Tree with the same structure, but its values updated based on the values from the incoming Trees. Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf in reverse order. If no flatten_mode() context manager is active, and flatten_mode is not given, all fields will be updated. If flatten_mode=\"normal\" is set, the output will have the exact same static components as the first input ( obj ). Examples: t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) update ( t1 , t2 ) # MyTree(x=1, y=2, z=4) When using update with multiple Trees the following equivalence holds: update(m1, m2, m3) = update(m1, update(m2, m3)) If you want to update the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) update ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the update process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches. Parameters: Name Type Description Default obj ~A Main pytree to update. required other ~A The pytree first to get the values to update from. required *rest ~A Additional pytree to perform the update in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/tree.py def update ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure, but its values updated based on the values from the incoming Trees. Updates are performed using the following rules: * For a list of equivalent leaves `l1, l2, ..., ln`, it returns the first non-`Nothing` leaf in reverse order. * If no `flatten_mode()` context manager is active, and `flatten_mode` is not given, all fields will be updated. * If `flatten_mode=\"normal\"` is set, the output will have the exact same static components as the first input (`obj`). Example: ```python t1 = MyTree(x=Nothing, y=2, z=3) t2 = MyTree(x=1, y=Nothing, z=4) update(t1, t2) # MyTree(x=1, y=2, z=4) ``` When using `update` with multiple Trees the following equivalence holds: ``` update(m1, m2, m3) = update(m1, update(m2, m3)) ``` If you want to update the current module instead of creating a new one use `inplace=True`. This is useful when applying transformation inside a method where reassigning `self` is not possible: ```python def double_params(self): # this is not doing what you expect self = jax.tree_map(lambda x: 2 * x, self) ``` Instead do this: ```python def double_params(self): doubled = jax.tree_map(lambda x: 2 * x, self) update(self, doubled, inplace=True) ``` If `inplace` is `True`, the input `obj` is mutated and returned. You can only update inplace if the input `obj` has a `__dict__` attribute, else a TypeError is raised. If `ignore_static` is `True`, static fields (according to the flattening mode) will be bypassed during the update process, the final output will have the same static components as the first input (`obj`). This strategy is a bit less safe in general as it will flatten all trees using `jax.tree_leaves` instead of `PyTreeDef.flatten_up_to`, this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches. Arguments: obj: Main pytree to update. other: The pytree first to get the values to update from. *rest: Additional pytree to perform the update in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treeo.update"},{"location":"user-guide/defining-fields/","text":"Tree fields are divided into two categories: node fields: they are considered as part of the pytree, JAX functions such as tree_map will operate over them. static fields: they are part of the PyTreeDef , JAX functions will not operate over them, but JAX is still aware of them, e.g. JAX will recompile jitted functions is case these fields change. import treeo as to @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John') Since field is just a wrapper over dataclasses.field that adds the node and kind arguments you can use all dataclass features. However, dataclasses are orthogonal to Treeo, this means that you can naturally use non-dataclass classes: class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) def __init__ ( self , height : float , name : str ): self . height = height self . name = name person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John')","title":"Defining Fields"},{"location":"user-guide/field-kinds/","text":"Kinds are associated types that give semantic meaning to a field (what it represents). A kind is just a type you pass to field via its kind argument. Kinds aremostly useful as metadata filtering via treeo.filter . For example, here is a possible definition for a BatchNorm module using kinds: import treeo as to class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) bias : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) var : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... Now with this definition you use filter to select specific kind of fields: model = BatchNorm ( ... ) # BatchNorm(scale=array(...), bias=array(...), mean=Nothing, var=Nothing) params = to . filter ( model , Parameter ) # filter by kind # BatchNorm(scale=Nothing, bias=Nothing, mean=array(...), var=array(...)) batch_stats = to . filter ( model , BatchStat ) This can be very useful to operate over specific subsets of your Trees e.g. sync subset of parameters across devices in a distributed computation.","title":"Field Kinds"},{"location":"user-guide/field-metadata/","text":"All metadata you set either with to.field or added by Treeo by default will be available in the field_metadata: Mapping[str, FieldMetadata] property. @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) mike = Person ( height = 1.5 , name = 'Mike' ) # no quite true, but you get the idea assert mike . field_metadata == { 'height' : FieldMetadata ( node = True , kind = NoneType , opaque = False , opaque_is_equal = None , ), 'name' : FieldMetadata ( node = False , kind = None , opaque = True , opaque_is_equal = None , ) } Changing field metadata If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Field Metadata"},{"location":"user-guide/field-metadata/#changing-field-metadata","text":"If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Changing field metadata"},{"location":"user-guide/intro/","text":"User Guide Before we start it would be useful to define some terminology that will be used throughout the documentation. Terminology Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"Intro"},{"location":"user-guide/intro/#user-guide","text":"Before we start it would be useful to define some terminology that will be used throughout the documentation.","title":"User Guide"},{"location":"user-guide/intro/#terminology","text":"Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"Terminology"},{"location":"user-guide/node-policy/","text":"If a field is not marked with to.field the following policy will be applied when determining whether a field is a node or not: If the field is annotated with a Tree subtype or a generic containing a Tree subtype e.g. List[to.Tree] , the field is considered a node . If the runtime value of the field is a to.Tree instance, the field is considered a node and the Tree 's metadata will be updated to reflect this. If none of the above apply, the field is considered a static field. import treeo as to class Agent ( to . Tree ): ... class Game ( to . Tree ): player : Agent # node cpus : List [ Agent ] # node max_cpus : int # static def __init__ ( self , ... ): ... self . boss = Agent ( ... ) # runtime node Note: the kind of all fields that are not explicitly declarated is set to NoneType .","title":"Node policy"},{"location":"user-guide/non-hashable-static-fields/","text":"Static fields are required to be hashable by JAX, so what happens if you want to have a static field that contains a non-hashable value like a numpy or jax array? For example: import treeo as to @dataclass class MyTree ( to . Tree ): table : np . ndarray One solution is to make that field opaque , this will work as long as you don't need jit and friends to reach to changes to its value content for recompiling. If you do, you can instead use the to.Hashable(value) class to wrap around it like this: @dataclass class MyTree ( to . Tree ): table : to . Hashable [ np . ndarray ] The hash from Hashable will only depend on object identity but not on the actual value , therefore you should treat it as immutable, if you want to update its content you should create a new Hashable instance: table = to . Hasable ( np . ones (( 10 , 10 ))) tree = MyTree ( table ) @jax . jit def do_something ( tree : MyTree ): table_value = tree . table . value # use Hashable.value ... tree = do_something ( tree ) # compiles tree = do_something ( tree ) # uses cache # update table module . table = to . Hashable ( np . zeros (( 10 , 10 ))) tree = do_something ( tree ) # recompiles Warning : If you are somehow able to mutate Hashable.value directly JAX won't know about this and jit won't recompile.","title":"Non-hashable static fields"},{"location":"user-guide/opaque-static-fields/","text":"When the value of a static field changes jit and friends will recompile to reflect posible changes in the computation logic. While this is good quality in many cases, sometimes certain fields are just there for metadata and should not part of the actual computation. For example, name in the Person example above will probably not affect the logic yet in this example it will force recompilation: @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # re-compiles \ud83d\ude41 To avoid this, you can mark a field as opaque : @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # cached! \ud83e\udd29 opaque will \"hide\" the value content of the field from JAX, changes will only be detected if the type of an opaque field changes or, in case its an array-like type, if its shape or dtype changes. opaque_is_equal If you want to define you on policy on how opaque fields are handled, you can use the opaque_is_equal: Callable[[to.Opaque, Any], bool] argument and pass a function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = True , opaque_is_equal = same_length , )","title":"Opaque static fields"},{"location":"user-guide/opaque-static-fields/#opaque_is_equal","text":"If you want to define you on policy on how opaque fields are handled, you can use the opaque_is_equal: Callable[[to.Opaque, Any], bool] argument and pass a function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = True , opaque_is_equal = same_length , )","title":"opaque_is_equal"},{"location":"user-guide/state-management/","text":"Treeo takes a \"direct\" approach to state management, i.e., state is updated in-place by the Tree whenever it needs to. For example, this module will calculate the running average of its input: @dataclass class Average ( to . Tree ): count : State [ jnp . ndarray ] = jnp . array ( 0 ) total : State [ jnp . ndarray ] = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count What is the catch? State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . update ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"State Management"},{"location":"user-guide/state-management/#what-is-the-catch","text":"State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . update ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"What is the catch?"},{"location":"user-guide/sugar/","text":"For pedagogical reason, field has been used throught the documentation to reinforce the concepts, however, Treeo has a couple of shortcuts to make it easier and more understandable to define Trees. normal shortcut to.field(node=True) to.node() to.field(node=False) to.static() to.field(node=True, kind=Kind) Kind.node() to.field(node=False, kind=Kind) Kind.static() Based on this, you can take the following code class Parameter : pass class Child ( to . Tree ): a : float = to . field ( node = True ) b : str = to . field ( node = False ) b : float = to . field ( node = True , kind = Parameter ) d : float = to . field ( node = False , kind = Parameter ) class Parent ( to . Tree ): child1 : Child = to . field ( node = True ) child2 : Child = to . field ( node = False ) rest : List [ Child ] = to . field ( node = True ) and simplify it to: class Parameter ( to . KindMixin ): pass class Child ( to . Tree ): a : float = to . node () b : str # = to.static(), inferred b : float = Parameter . node () d : float = Parameter . static () class Parent ( to . Tree ): child1 : Child # = to.node(), inferred child2 : Child = to . static () rest : List [ Child ] # = to.node(), inferred The to.KindMixin provides the .field() , .node() , and .static() methods to subtypes, in this case the Parameter class.","title":"Sugar \ud83c\udf6c"},{"location":"user-guide/api/filter/","text":"The filter function allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. tree = MyTree ( a = jnp . array ( 1 ), b = jnp . array ( 2 )) to . filter ( tree , Parameter ) # MyTree(a=array(1), b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=array(2)) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: jax . tree_map ( lambda x : - x , to . filter ( tree , Parameter )) # MyTree(a=array(-1), b=Nothing) jax . tree_map ( lambda x : - x , to . filter ( tree , BatchStat )) # MyTree(a=Nothing, b=array([-2])) filter predicates If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np . array ( 2 ), jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.array(2), jnp.array([3.0, 4.0])] multiple filters You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing)","title":"Filter"},{"location":"user-guide/api/filter/#filter-predicates","text":"If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np . array ( 2 ), jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.array(2), jnp.array([3.0, 4.0])]","title":"filter predicates"},{"location":"user-guide/api/filter/#multiple-filters","text":"You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing)","title":"multiple filters"},{"location":"user-guide/api/intro/","text":"Throught these examples for the functional API we will use the following defintions: import treeo as to class Parameter : pass class BatchStat : pass @dataclass class MyTree ( to . Tree ): a : jnp . ndarray = to . field ( node = True , kind = Parameter ) b : jnp . ndarray = to . field ( node = True , kind = BatchStat )","title":"Intro"},{"location":"user-guide/api/map/","text":"The map function provides a convenient way to map a function over the fields of a pytree: import treeo as to tree = MyTree ( a = jnp . array ( 1 ), b = jnp . array ( 2 )) params = to . filter ( tree , Parameter ) # MyTree(a=array(1), b=Nothing) negative = to . map ( lambda x : - x , params ) # MyTree(a=array(-1), b=Nothing) tree = to . update ( tree , negative ) # MyTree(a=array(-1), b=array(2)) Up to this point map is behaving just like jax.tree_map , however, the pattern in the previous example is so common that map s main use is providing a shortcut for applying filter -> tree_map -> update in sequence: tree = MyTree ( a = jnp . array ( 1 ), b = jnp . array ( 2 )) tree = to . map ( lambda x : - x , tree , Parameter ) # MyTree(a=array(-1), b=array(2)) As shown here, map accepts the same *args as filter and calls update at the end if filters are given.","title":"Map"},{"location":"user-guide/api/update/","text":"The update function allows you to merge the values of one or more incoming pytrees with the current pytree, this is useful for integrating filtered Trees back into the main Tree. import treeo as to tree = MyTree ( a = jnp . array ( 1 ), b = jnp . array ( 2 )) params = to . filter ( tree , Parameter ) # MyTree(a=array(1), b=Nothing) negative = jax . tree_map ( lambda x : - x , params ) # MyTree(a=array(-1), b=Nothing) tree = to . update ( tree , negative ) # MyTree(a=array(-1), b=array(2)) Since update works on pytrees in general, the following works: t1 = ( to . NOTHING , 4 ) t2 = ( 5 , to . NOTHING ) to . update ( t1 , t2 ) # (5, 4)","title":"Update"}]}