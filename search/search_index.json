{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Treeo A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo lets you easily create class-based Pytrees so your custom objects can easily interact seamlessly with JAX. Uses of Treeo can range from just creating simple simple JAX-aware utility classes to using it as the core abstraction for full-blown frameworks. Treeo was originally extracted from the core of Treex and shares a lot in common with flax.struct . Documentation | User Guide Installation Install using pip: pip install treeo Basics With Treeo you can easily define your own custom Pytree classes by inheriting from Treeo's Tree class and using the field function to declare which fields are nodes (childs) and which are static (metadata): import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! field is just a wrapper around dataclasses.field so you can define your Pytrees as dataclasses, but Treeo fully supports non-dataclass classes as well. Since all Tree instances are Pytree they work with the various functions from the jax library as expected: p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John') Kinds Treeo also include a kind system that lets you give semantic meaning to fields (what a field represents within your application). A kind is just a type you pass to field via its kind argument: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) Kinds are very useful as a filtering mechanism via treeo.filter : model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) Nothing behaves like None in Python, but it is a special value that is used to represent the absence of a value within Treeo. Treeo also offers the merge function which lets you rejoin filtered Trees with a logic similar to Python dict.update but done recursively: def loss_fn ( params , model , ... ): # add traced params to model model = to . merge ( model , params ) ... # gradient only w.r.t. params params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... ) For a more in-depth tour check out the User Guide . Examples A simple Tree from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 ) A Stateful Tree from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) @jax . jit def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree Full Example - Linear Regression import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import treeo as to class Linear ( to . Tree ): w : jnp . ndarray = to . node () b : jnp . ndarray = to . node () def __init__ ( self , din , dout , key ): self . w = jax . random . uniform ( key , shape = ( din , dout )) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @jax . value_and_grad def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad @jax . jit def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) model = jax . tree_map ( sgd , model , grads ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) key = jax . random . PRNGKey ( 0 ) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Getting Started"},{"location":"#treeo","text":"A small library for creating and manipulating custom JAX Pytree classes Light-weight : has no dependencies other than jax . Compatible : Treeo Tree objects are compatible with any jax function that accepts Pytrees. Standards-based : treeo.field is built on top of python's dataclasses.field . Flexible : Treeo is compatible with both dataclass and non-dataclass classes. Treeo lets you easily create class-based Pytrees so your custom objects can easily interact seamlessly with JAX. Uses of Treeo can range from just creating simple simple JAX-aware utility classes to using it as the core abstraction for full-blown frameworks. Treeo was originally extracted from the core of Treex and shares a lot in common with flax.struct . Documentation | User Guide","title":"Treeo"},{"location":"#installation","text":"Install using pip: pip install treeo","title":"Installation"},{"location":"#basics","text":"With Treeo you can easily define your own custom Pytree classes by inheriting from Treeo's Tree class and using the field function to declare which fields are nodes (childs) and which are static (metadata): import treeo as to @dataclass class Person ( to . Tree ): height : jnp . array = to . field ( node = True ) # I am a node field! name : str = to . field ( node = False ) # I am a static field! field is just a wrapper around dataclasses.field so you can define your Pytrees as dataclasses, but Treeo fully supports non-dataclass classes as well. Since all Tree instances are Pytree they work with the various functions from the jax library as expected: p = Person ( height = jnp . array ( 1.8 ), name = \"John\" ) # Trees can be jitted! jax . jit ( lambda person : person )( p ) # Person(height=array(1.8), name='John') # Trees can be mapped! jax . tree_map ( lambda x : 2 * x , p ) # Person(height=array(3.6), name='John')","title":"Basics"},{"location":"#kinds","text":"Treeo also include a kind system that lets you give semantic meaning to fields (what a field represents within your application). A kind is just a type you pass to field via its kind argument: class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) Kinds are very useful as a filtering mechanism via treeo.filter : model = BatchNorm ( ... ) # select only Parameters, mean is filtered out params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) Nothing behaves like None in Python, but it is a special value that is used to represent the absence of a value within Treeo. Treeo also offers the merge function which lets you rejoin filtered Trees with a logic similar to Python dict.update but done recursively: def loss_fn ( params , model , ... ): # add traced params to model model = to . merge ( model , params ) ... # gradient only w.r.t. params params = to . filter ( model , Parameter ) # BatchNorm(scale=array(...), mean=Nothing) grads = jax . grad ( loss_fn )( params , model , ... ) For a more in-depth tour check out the User Guide .","title":"Kinds"},{"location":"#examples","text":"","title":"Examples"},{"location":"#a-simple-tree","text":"from dataclasses import dataclass import treeo as to @dataclass class Character ( to . Tree ): position : jnp . ndarray = to . field ( node = True ) # node field name : str = to . field ( node = False , opaque = True ) # static field character = Character ( position = jnp . array ([ 0 , 0 ]), name = 'Adam' ) # character can freely pass through jit @jax . jit def update ( character : Character , velocity , dt ) -> Character : character . position += velocity * dt return character character = update ( character velocity = jnp . array ([ 1.0 , 0.2 ]), dt = 0.1 )","title":"A simple Tree"},{"location":"#a-stateful-tree","text":"from dataclasses import dataclass import treeo as to @dataclass class Counter ( to . Tree ): n : jnp . array = to . field ( default = jnp . array ( 0 ), node = True ) # node step : int = to . field ( default = 1 , node = False ) # static def inc ( self ): self . n += self . step counter = Counter ( step = 2 ) # Counter(n=jnp.array(0), step=2) @jax . jit def update ( counter : Counter ): counter . inc () return counter counter = update ( counter ) # Counter(n=jnp.array(2), step=2) # map over the tree","title":"A Stateful Tree"},{"location":"#full-example-linear-regression","text":"import jax import jax.numpy as jnp import matplotlib.pyplot as plt import numpy as np import treeo as to class Linear ( to . Tree ): w : jnp . ndarray = to . node () b : jnp . ndarray = to . node () def __init__ ( self , din , dout , key ): self . w = jax . random . uniform ( key , shape = ( din , dout )) self . b = jnp . zeros ( shape = ( dout ,)) def __call__ ( self , x ): return jnp . dot ( x , self . w ) + self . b @jax . value_and_grad def loss_fn ( model , x , y ): y_pred = model ( x ) loss = jnp . mean (( y_pred - y ) ** 2 ) return loss def sgd ( param , grad ): return param - 0.1 * grad @jax . jit def train_step ( model , x , y ): loss , grads = loss_fn ( model , x , y ) model = jax . tree_map ( sgd , model , grads ) return loss , model x = np . random . uniform ( size = ( 500 , 1 )) y = 1.4 * x - 0.3 + np . random . normal ( scale = 0.1 , size = ( 500 , 1 )) key = jax . random . PRNGKey ( 0 ) model = Linear ( 1 , 1 , key = key ) for step in range ( 1000 ): loss , model = train_step ( model , x , y ) if step % 100 == 0 : print ( f \"loss: { loss : .4f } \" ) X_test = np . linspace ( x . min (), x . max (), 100 )[:, None ] y_pred = model ( X_test ) plt . scatter ( x , y , c = \"k\" , label = \"data\" ) plt . plot ( X_test , y_pred , c = \"b\" , linewidth = 2 , label = \"prediction\" ) plt . legend () plt . show ()","title":"Full Example - Linear Regression"},{"location":"api/Apply/","text":"treeo.Apply Mixin that adds a .apply() method to the class. apply ( self , f , * rest , * , inplace = False ) apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"Apply"},{"location":"api/Apply/#treeoapply","text":"Mixin that adds a .apply() method to the class.","title":"treeo.Apply"},{"location":"api/Apply/#treeo.mixins.Apply.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/ArrayLike/","text":"treeo.ArrayLike __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/utils.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/utils.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/utils.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"ArrayLike"},{"location":"api/ArrayLike/#treeoarraylike","text":"","title":"treeo.ArrayLike"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__","text":"","title":"__class__"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/utils.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/utils.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/utils.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/ArrayLike/#treeo.utils.ArrayLike.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/utils.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Copy/","text":"treeo.Copy Mixin that adds a .copy() method to the class. copy ( self ) copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self ): \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return api . copy ( self )","title":"Copy"},{"location":"api/Copy/#treeocopy","text":"Mixin that adds a .copy() method to the class.","title":"treeo.Copy"},{"location":"api/Copy/#treeo.mixins.Copy.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self ): \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return api . copy ( self )","title":"copy()"},{"location":"api/Extensions/","text":"treeo.Extensions Mixin that adds all available mixins from treeo.mixins . __repr__ ( self ) inherited special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , ) apply ( self , f , * rest , * , inplace = False ) inherited apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace ) copy ( self ) inherited copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self ): \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return api . copy ( self ) filter ( self , * filters , * , inplace = False , flatten_mode = None ) inherited filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode ) map ( self , f , * filters , * , inplace = False , flatten_mode = None ) inherited map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode ) merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) inherited merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , ) to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) inherited to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , ) to_string ( self , * , private_fields = False , static_fields = True , color = False ) inherited to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"Extensions"},{"location":"api/Extensions/#treeoextensions","text":"Mixin that adds all available mixins from treeo.mixins .","title":"treeo.Extensions"},{"location":"api/Extensions/#treeo.mixins.Extensions.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/Extensions/#treeo.mixins.Extensions.apply","text":"apply is a wrapper over treeo.apply that passes self as the second argument. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/mixins.py def apply ( self : A , f : tp . Callable [ ... , None ], * rest : A , inplace : bool = False ) -> A : \"\"\" `apply` is a wrapper over `treeo.apply` that passes `self` as the second argument. Arguments: f: The function to apply. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" return api . apply ( f , self , * rest , inplace = inplace )","title":"apply()"},{"location":"api/Extensions/#treeo.mixins.Extensions.copy","text":"copy is a wrapper over treeo.copy that passes self as the first argument. Source code in treeo/mixins.py def copy ( self ): \"\"\" `copy` is a wrapper over `treeo.copy` that passes `self` as the first argument. \"\"\" return api . copy ( self )","title":"copy()"},{"location":"api/Extensions/#treeo.mixins.Extensions.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Extensions/#treeo.mixins.Extensions.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"map()"},{"location":"api/Extensions/#treeo.mixins.Extensions.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/Extensions/#treeo.mixins.Extensions.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/FieldInfo/","text":"treeo.FieldInfo","title":"FieldInfo"},{"location":"api/FieldInfo/#treeofieldinfo","text":"","title":"treeo.FieldInfo"},{"location":"api/FieldMetadata/","text":"treeo.FieldMetadata","title":"FieldMetadata"},{"location":"api/FieldMetadata/#treeofieldmetadata","text":"","title":"treeo.FieldMetadata"},{"location":"api/Filter/","text":"treeo.Filter Mixin that adds a .filter() method to the class. filter ( self , * filters , * , inplace = False , flatten_mode = None ) filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"Filter"},{"location":"api/Filter/#treeofilter","text":"Mixin that adds a .filter() method to the class.","title":"treeo.Filter"},{"location":"api/Filter/#treeo.mixins.Filter.filter","text":"filter is a wrapper over treeo.filter that passes self as the first argument. Parameters: Name Type Description Default *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/mixins.py def filter ( self : A , * filters : api . Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `filter` is a wrapper over `treeo.filter` that passes `self` as the first argument. Arguments: *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" return api . filter ( self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"filter()"},{"location":"api/Hashable/","text":"treeo.Hashable A hashable immutable wrapper around non-hashable values","title":"Hashable"},{"location":"api/Hashable/#treeohashable","text":"A hashable immutable wrapper around non-hashable values","title":"treeo.Hashable"},{"location":"api/KindMixin/","text":"treeo.KindMixin","title":"KindMixin"},{"location":"api/KindMixin/#treeokindmixin","text":"","title":"treeo.KindMixin"},{"location":"api/MISSING/","text":"treeo.MISSING","title":"MISSING"},{"location":"api/MISSING/#treeomissing","text":"","title":"treeo.MISSING"},{"location":"api/Map/","text":"treeo.Map Mixin that adds a .map() method to the class. map ( self , f , * filters , * , inplace = False , flatten_mode = None ) map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"Map"},{"location":"api/Map/#treeomap","text":"Mixin that adds a .map() method to the class.","title":"treeo.Map"},{"location":"api/Map/#treeo.mixins.Map.map","text":"map is a wrapper over treeo.map that passes self as the second argument. Parameters: Name Type Description Default f Callable The function to apply to the leaves. required *filters Filter The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/mixins.py def map ( self : A , f : tp . Callable , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ) -> A : \"\"\" `map` is a wrapper over `treeo.map` that passes `self` as the second argument. Arguments: f: The function to apply to the leaves. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" return api . map ( f , self , * filters , inplace = inplace , flatten_mode = flatten_mode )","title":"map()"},{"location":"api/Merge/","text":"treeo.Merge Mixin that adds a .merge() method to the class. merge ( self , other , * rest , * , inplace = False , flatten_mode = None , ignore_static = False ) merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"Merge"},{"location":"api/Merge/#treeomerge","text":"Mixin that adds a .merge() method to the class.","title":"treeo.Merge"},{"location":"api/Merge/#treeo.mixins.Merge.merge","text":"merge is a wrapper over treeo.merge that passes self as the first argument. Parameters: Name Type Description Default other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the merged values. If inplace is True , obj is returned. Source code in treeo/mixins.py def merge ( self : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ api . FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" `merge` is a wrapper over `treeo.merge` that passes `self` as the first argument. Arguments: other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the merged values. If `inplace` is `True`, `obj` is returned. \"\"\" return api . merge ( self , other , * rest , inplace = inplace , flatten_mode = flatten_mode , ignore_static = ignore_static , )","title":"merge()"},{"location":"api/Missing/","text":"treeo.Missing","title":"Missing"},{"location":"api/Missing/#treeomissing","text":"","title":"treeo.Missing"},{"location":"api/NOTHING/","text":"treeo.NOTHING","title":"NOTHING"},{"location":"api/NOTHING/#treeonothing","text":"","title":"treeo.NOTHING"},{"location":"api/Nothing/","text":"treeo.Nothing","title":"Nothing"},{"location":"api/Nothing/#treeonothing","text":"","title":"treeo.Nothing"},{"location":"api/Opaque/","text":"treeo.Opaque","title":"Opaque"},{"location":"api/Opaque/#treeoopaque","text":"","title":"treeo.Opaque"},{"location":"api/Repr/","text":"treeo.Repr Mixin that adds a __repr__ method to the class. __repr__ ( self ) special Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"Repr"},{"location":"api/Repr/#treeorepr","text":"Mixin that adds a __repr__ method to the class.","title":"treeo.Repr"},{"location":"api/Repr/#treeo.mixins.Repr.__repr__","text":"Uses treeo.to_string to generate a string representation of the object. Source code in treeo/mixins.py def __repr__ ( self ) -> tp . Any : \"\"\" Uses `treeo.to_string` to generate a string representation of the object. \"\"\" return api . to_string ( self , private_fields = False , static_fields = True , color = False , )","title":"__repr__()"},{"location":"api/ToDict/","text":"treeo.ToDict Mixin that adds a .to_dict() method to the class. to_dict ( self , * , private_fields = False , static_fields = True , type_info = False , field_info = False ) to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"ToDict"},{"location":"api/ToDict/#treeotodict","text":"Mixin that adds a .to_dict() method to the class.","title":"treeo.ToDict"},{"location":"api/ToDict/#treeo.mixins.ToDict.to_dict","text":"to_dict is a wrapper over treeo.to_dict that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True type_info bool If True , type information is included. False field_info bool If True , field information is included. False Returns: Type Description Any A dict representation of the object. Source code in treeo/mixins.py def to_dict ( self , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : \"\"\" `to_dict` is a wrapper over `treeo.to_dict` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. type_info: If `True`, type information is included. field_info: If `True`, field information is included. Returns: A dict representation of the object. \"\"\" return api . to_dict ( self , private_fields = private_fields , static_fields = static_fields , type_info = type_info , field_info = field_info , )","title":"to_dict()"},{"location":"api/ToString/","text":"treeo.ToString Mixin that adds a .to_string() method to the class. to_string ( self , * , private_fields = False , static_fields = True , color = False ) to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"ToString"},{"location":"api/ToString/#treeotostring","text":"Mixin that adds a .to_string() method to the class.","title":"treeo.ToString"},{"location":"api/ToString/#treeo.mixins.ToString.to_string","text":"to_string is a wrapper over treeo.to_string that passes self as the first argument. Parameters: Name Type Description Default private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True color bool If True , color is included. False Returns: Type Description str A string representation of the object. Source code in treeo/mixins.py def to_string ( self : A , * , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" `to_string` is a wrapper over `treeo.to_string` that passes `self` as the first argument. Arguments: private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. color: If `True`, color is included. Returns: A string representation of the object. \"\"\" return api . to_string ( self , private_fields = private_fields , static_fields = static_fields , color = color , )","title":"to_string()"},{"location":"api/Tree/","text":"treeo.Tree __class__ inherited __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], opaque_is_equal = value . metadata [ \"opaque_is_equal\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , opaque_is_equal = None , ) check_metadata_updates ( self ) Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"Tree"},{"location":"api/Tree/#treeotree","text":"","title":"treeo.Tree"},{"location":"api/Tree/#treeo.tree.Tree.__class__","text":"","title":"__class__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__class__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/Tree/#treeo.tree.Tree.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in treeo/tree.py def __init_subclass__ ( cls ): jax . tree_util . register_pytree_node_class ( cls ) # Restore the signature sig = inspect . signature ( cls . __init__ ) parameters = tuple ( sig . parameters . values ()) cls . __signature__ = sig . replace ( parameters = parameters [ 1 :]) annotations = utils . _get_all_annotations ( cls ) class_vars = utils . _get_all_vars ( cls ) cls . _field_metadata = {} cls . _factory_fields = {} cls . _default_field_values = {} for field , value in class_vars . items (): if isinstance ( value , dataclasses . Field ): # save defaults if value . default is not dataclasses . MISSING : cls . _default_field_values [ field ] = value . default elif value . default_factory is not dataclasses . MISSING : cls . _factory_fields [ field ] = value . default_factory # extract metadata if value . metadata is not None and \"node\" in value . metadata : cls . _field_metadata [ field ] = types . FieldMetadata ( node = value . metadata [ \"node\" ], kind = value . metadata [ \"kind\" ], opaque = value . metadata [ \"opaque\" ], opaque_is_equal = value . metadata [ \"opaque_is_equal\" ], ) for field , value in annotations . items (): if field not in cls . _field_metadata : is_node = any ( issubclass ( t , Tree ) for t in utils . _all_types ( value )) cls . _field_metadata [ field ] = types . FieldMetadata ( node = is_node , kind = type ( None ), opaque = False , opaque_is_equal = None , )","title":"__init_subclass__()"},{"location":"api/Tree/#treeo.tree.Tree.check_metadata_updates","text":"Checks for new fields, if found, adds them to the metadata. Source code in treeo/tree.py def check_metadata_updates ( self ): \"\"\" Checks for new fields, if found, adds them to the metadata. \"\"\" with _CONTEXT . update ( flatten_mode = FlattenMode . all_fields ): jax . tree_flatten ( self )","title":"check_metadata_updates()"},{"location":"api/TreeMeta/","text":"treeo.TreeMeta __base__ inherited Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). __instancecheck__ ( cls , instance ) special Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance ) __new__ ( mcls , name , bases , namespace , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls __subclasscheck__ ( cls , subclass ) special Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass ) register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass ) register ( cls , subclass ) inherited Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"TreeMeta"},{"location":"api/TreeMeta/#treeotreemeta","text":"","title":"treeo.TreeMeta"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__","text":"Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).","title":"__base__"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__instancecheck__","text":"Override for isinstance(instance, cls). Source code in treeo/tree.py def __instancecheck__ ( cls , instance ): \"\"\"Override for isinstance(instance, cls).\"\"\" return _abc_instancecheck ( cls , instance )","title":"__instancecheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in treeo/tree.py def __new__ ( mcls , name , bases , namespace , ** kwargs ): cls = super () . __new__ ( mcls , name , bases , namespace , ** kwargs ) _abc_init ( cls ) return cls","title":"__new__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.__subclasscheck__","text":"Override for issubclass(subclass, cls). Source code in treeo/tree.py def __subclasscheck__ ( cls , subclass ): \"\"\"Override for issubclass(subclass, cls).\"\"\" return _abc_subclasscheck ( cls , subclass )","title":"__subclasscheck__()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.__base__.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/TreeMeta/#treeo.tree.TreeMeta.register","text":"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. Source code in treeo/tree.py def register ( cls , subclass ): \"\"\"Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. \"\"\" return _abc_register ( cls , subclass )","title":"register()"},{"location":"api/add_field_info/","text":"treeo.add_field_info A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"add_field_info"},{"location":"api/add_field_info/#treeoadd_field_info","text":"A context manager that makes Tree s produce leaves as FieldInfo when flattening. Source code in treeo/api.py @contextmanager def add_field_info (): \"\"\" A context manager that makes `Tree`s produce leaves as `FieldInfo` when flattening. \"\"\" with tree_m . _CONTEXT . update ( add_field_info = True ): yield","title":"treeo.add_field_info"},{"location":"api/apply/","text":"treeo.apply Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"apply"},{"location":"api/apply/#treeoapply","text":"Applies a function to all to.Tree s in a Pytree. Works very similar to jax.tree_map , but its values are to.Tree s instead of leaves, also f should apply the changes inplace to Tree object. If inplace is False , a copy of the first object is returned with the changes applied. The rest of the objects are always copied. Parameters: Name Type Description Default f Callable[..., NoneType] The function to apply. required obj ~A a pytree possibly containing Trees. required *rest ~A additional pytrees. () inplace bool If True , the input obj is mutated. False Returns: Type Description ~A A new pytree with the updated Trees or the same input obj if inplace is True . Source code in treeo/api.py def apply ( f : tp . Callable [ ... , None ], obj : A , * rest : A , inplace : bool = False ) -> A : \"\"\" Applies a function to all `to.Tree`s in a Pytree. Works very similar to `jax.tree_map`, but its values are `to.Tree`s instead of leaves, also `f` should apply the changes inplace to Tree object. If `inplace` is `False`, a copy of the first object is returned with the changes applied. The `rest` of the objects are always copied. Arguments: f: The function to apply. obj: a pytree possibly containing Trees. *rest: additional pytrees. inplace: If `True`, the input `obj` is mutated. Returns: A new pytree with the updated Trees or the same input `obj` if `inplace` is `True`. \"\"\" rest = copy ( rest ) if not inplace : obj = copy ( obj ) objs = ( obj ,) + rest def nested_fn ( obj , * rest ): if isinstance ( obj , Tree ): apply ( f , obj , * rest , inplace = True ) jax . tree_map ( nested_fn , * objs , is_leaf = lambda x : isinstance ( x , Tree ) and not x in objs , ) if isinstance ( obj , Tree ): f ( obj , * rest ) return obj","title":"treeo.apply"},{"location":"api/field/","text":"treeo.field Source code in treeo/utils.py def field ( default = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , \"opaque_is_equal\" : opaque_is_equal , }, default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , )","title":"field"},{"location":"api/field/#treeofield","text":"Source code in treeo/utils.py def field ( default = dataclasses . MISSING , * , node : bool , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return dataclasses . field ( default = default , metadata = { \"node\" : node , \"kind\" : kind , \"opaque\" : opaque , \"opaque_is_equal\" : opaque_is_equal , }, default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , )","title":"treeo.field"},{"location":"api/filter/","text":"treeo.filter The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"filter"},{"location":"api/filter/#treeofilter","text":"The filter function allows you to select a subtree by filtering based on a predicate or kind type, leaves that pass all filters are kept, the rest are set to Nothing . For more information see filter's user guide . Parameters: Name Type Description Default obj ~A A pytree (possibly containing to.Tree s) to be filtered. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] Types to filter by, membership is determined by issubclass , or callables that take in a FieldInfo and return a bool . () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation. None Returns: Type Description ~A A new pytree with the filtered fields. If inplace is True , obj is returned. Source code in treeo/api.py def filter ( obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" The `filter` function allows you to select a subtree by filtering based on a predicate or `kind` type, leaves that pass all filters are kept, the rest are set to `Nothing`. For more information see [filter's user guide](https://cgarciae.github.io/treeo/user-guide/api/filter). Arguments: obj: A pytree (possibly containing `to.Tree`s) to be filtered. *filters: Types to filter by, membership is determined by `issubclass`, or callables that take in a `FieldInfo` and return a `bool`. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation. Returns: A new pytree with the filtered fields. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot filter inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj filters = tuple ( _get_kind_filter ( f ) if isinstance ( f , tp . Type ) else f for f in filters ) def apply_filters ( info : tp . Any ) -> tp . Any : if not isinstance ( info , FieldInfo ): info = FieldInfo ( name = None , value = info , kind = type ( None ), module = None , ) assert isinstance ( info , FieldInfo ) return info . value if all ( f ( info ) for f in filters ) else types . NOTHING with tree_m . _CONTEXT . update ( add_field_info = True ), _flatten_context ( flatten_mode ): obj = jax . tree_map ( apply_filters , obj ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treeo.filter"},{"location":"api/map/","text":"treeo.map Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"map"},{"location":"api/map/#treeomap","text":"Applies a function to all leaves in a pytree using jax.tree_map , if filters are given then the function will be applied only to the subset of leaves that match the filters. For more information see map's user guide . Parameters: Name Type Description Default f Callable The function to apply to the leaves. required obj ~A a pytree possibly containing to.Tree s. required *filters Union[Type[Any], Callable[[FieldInfo], bool]] The filters used to select the leaves to which the function will be applied. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. None Returns: Type Description ~A A new pytree with the changes applied. If inplace is True , the input obj is returned. Source code in treeo/api.py def map ( f : tp . Callable , obj : A , * filters : Filter , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ) -> A : \"\"\" Applies a function to all leaves in a pytree using `jax.tree_map`, if `filters` are given then the function will be applied only to the subset of leaves that match the filters. For more information see [map's user guide](https://cgarciae.github.io/treeo/user-guide/api/map). Arguments: f: The function to apply to the leaves. obj: a pytree possibly containing `to.Tree`s. *filters: The filters used to select the leaves to which the function will be applied. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. Returns: A new pytree with the changes applied. If `inplace` is `True`, the input `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise ValueError ( f \"Cannot map inplace on objects with no __dict__ property, got { obj } \" ) input_obj = obj has_filters = len ( filters ) > 0 with _flatten_context ( flatten_mode ): if has_filters : new_obj = filter ( obj , * filters ) else : new_obj = obj new_obj : A = jax . tree_map ( f , new_obj ) if has_filters : new_obj = merge ( obj , new_obj ) if inplace : input_obj . __dict__ . update ( new_obj . __dict__ ) return input_obj else : return new_obj","title":"treeo.map"},{"location":"api/merge/","text":"treeo.merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"merge"},{"location":"api/merge/#treeomerge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see merge's user guide . Parameters: Name Type Description Default obj ~A Main pytree to merge. required other ~A The pytree first to get the values to merge with. required *rest ~A Additional pytree to perform the merge in order from left to right. () inplace bool If True , the input obj is mutated and returned. False flatten_mode Union[treeo.tree.FlattenMode, str] Sets a new FlattenMode context for the operation, if None the current context is used. If the current flatten context is None and flatten_mode is not passed then FlattenMode.all_fields is used. None ignore_static bool If True , bypasses static fields during the process and the statics fields for output are taken from the first input ( obj ). False Returns: Type Description ~A A new pytree with the updated values. If inplace is True , obj is returned. Source code in treeo/api.py def merge ( obj : A , other : A , * rest : A , inplace : bool = False , flatten_mode : tp . Union [ FlattenMode , str , None ] = None , ignore_static : bool = False , ) -> A : \"\"\" Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. For more information see [merge's user guide](https://cgarciae.github.io/treeo/user-guide/api/merge). Arguments: obj: Main pytree to merge. other: The pytree first to get the values to merge with. *rest: Additional pytree to perform the merge in order from left to right. inplace: If `True`, the input `obj` is mutated and returned. flatten_mode: Sets a new `FlattenMode` context for the operation, if `None` the current context is used. If the current flatten context is `None` and `flatten_mode` is not passed then `FlattenMode.all_fields` is used. ignore_static: If `True`, bypasses static fields during the process and the statics fields for output are taken from the first input (`obj`). Returns: A new pytree with the updated values. If `inplace` is `True`, `obj` is returned. \"\"\" if inplace and not hasattr ( obj , \"__dict__\" ): raise TypeError ( f \"Cannot update inplace on objects with no __dict__ property, got { obj } \" ) if flatten_mode is None and tree_m . _CONTEXT . flatten_mode is None : flatten_mode = FlattenMode . all_fields input_obj = obj def merge_fn ( * xs ): for x in reversed ( xs ): if not isinstance ( x , types . Nothing ): return x return types . NOTHING tree_map_fn = _looser_tree_map if ignore_static else jax . tree_map with _flatten_context ( flatten_mode ): obj = tree_map_fn ( merge_fn , obj , other , * rest , is_leaf = lambda x : isinstance ( x , LEAF_TYPES ), ) if inplace : input_obj . __dict__ . update ( obj . __dict__ ) return input_obj else : return obj","title":"treeo.merge"},{"location":"api/node/","text":"treeo.node Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"node"},{"location":"api/node/#treeonode","text":"Source code in treeo/utils.py def node ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default = default , node = True , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"treeo.node"},{"location":"api/static/","text":"treeo.static Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"static"},{"location":"api/static/#treeostatic","text":"Source code in treeo/utils.py def static ( default = dataclasses . MISSING , * , kind : type = type ( None ), default_factory = dataclasses . MISSING , init : bool = True , repr : bool = True , hash : tp . Optional [ bool ] = None , compare : bool = True , opaque : bool = False , opaque_is_equal : tp . Optional [ tp . Callable [[ Opaque , tp . Any ], bool ]] = None , ) -> tp . Any : return field ( default , node = False , kind = kind , default_factory = default_factory , init = init , repr = repr , hash = hash , compare = compare , opaque = opaque , opaque_is_equal = opaque_is_equal , )","title":"treeo.static"},{"location":"api/to_dict/","text":"treeo.to_dict Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"to_dict"},{"location":"api/to_dict/#treeoto_dict","text":"Source code in treeo/api.py def to_dict ( obj : tp . Any , * , private_fields : bool = False , static_fields : bool = True , type_info : bool = False , field_info : bool = False , ) -> tp . Any : if field_info : with add_field_info (), flatten_mode ( FlattenMode . all_fields ): flat , treedef = jax . tree_flatten ( obj ) obj = jax . tree_unflatten ( treedef , flat ) obj = apply ( _remove_field_info_from_metadata , obj ) return _to_dict ( obj , private_fields , static_fields , type_info )","title":"treeo.to_dict"},{"location":"api/to_string/","text":"treeo.to_string Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"to_string"},{"location":"api/to_string/#treeoto_string","text":"Converts a pytree to a string representation. Parameters: Name Type Description Default obj Any The pytree to convert. required private_fields bool If True , private fields are included. False static_fields bool If True , static fields are included. True Returns: Type Description str A string representation of the pytree. Source code in treeo/api.py def to_string ( obj : tp . Any , private_fields : bool = False , static_fields : bool = True , color : bool = False , ) -> str : \"\"\" Converts a pytree to a string representation. Arguments: obj: The pytree to convert. private_fields: If `True`, private fields are included. static_fields: If `True`, static fields are included. Returns: A string representation of the pytree. \"\"\" dict_ = to_dict ( obj , private_fields = private_fields , static_fields = static_fields , type_info = True , field_info = True , ) global RICH_WARNING_COUNT rep = _to_string ( dict_ , level = 0 , inline = False , color = color , space = \" \" ) rep = _add_padding ( rep ) if color : if Console is None or Text is None : if RICH_WARNING_COUNT < 1 : RICH_WARNING_COUNT += 1 logging . warning ( f \"'rich' library not available, install `rich` to get colors.\" ) else : rep = _get_rich_repr ( Text . from_markup ( rep )) return rep","title":"treeo.to_string"},{"location":"user-guide/defining-fields/","text":"Tree fields are divided into two categories: node fields: they are considered as part of the pytree, JAX functions such as tree_map will operate over them. static fields: they are part of the PyTreeDef , JAX functions will not operate over them, but JAX is still aware of them, e.g. JAX will recompile jitted functions is case these fields change. import treeo as to @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John') Since field is just a wrapper over dataclasses.field that adds the node and kind arguments you can use all dataclass features. However, dataclasses are orthogonal to Treeo, this means that you can naturally use non-dataclass classes: class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) def __init__ ( self , height : float , name : str ): self . height = height self . name = name person = Person ( height = 1.5 , name = 'John' ) tree_map ( lambda x : x + 1 , person ) # Person(height=2.5, name='John')","title":"Defining Fields"},{"location":"user-guide/field-kinds/","text":"Kinds are associated types that give semantic meaning to a field (what it represents). A kind is just a type you pass to field via its kind argument. Kinds are mostly useful as metadata filtering via treeo.filter . For example, here is a possible definition for a BatchNorm module using kinds: import treeo as to class Parameter : pass class BatchStat : pass class BatchNorm ( to . Tree ): scale : jnp . ndarray = to . field ( node = True , kind = Parameter ) bias : jnp . ndarray = to . field ( node = True , kind = Parameter ) mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) var : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... Now with this definition you use filter to select specific kind of fields: model = BatchNorm ( ... ) # BatchNorm(scale=array(...), bias=array(...), mean=Nothing, var=Nothing) params = to . filter ( model , Parameter ) # filter by kind # BatchNorm(scale=Nothing, bias=Nothing, mean=array(...), var=array(...)) batch_stats = to . filter ( model , BatchStat ) This can be very useful to operate over specific subsets of your Trees e.g. sync subset of parameters across devices in a distributed computation.","title":"Field Kinds"},{"location":"user-guide/field-metadata/","text":"All metadata you set either with to.field or added by Treeo by default will be available in the field_metadata: Mapping[str, FieldMetadata] property. @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) mike = Person ( height = 1.5 , name = 'Mike' ) # no quite true, but you get the idea assert mike . field_metadata == { 'height' : FieldMetadata ( node = True , kind = NoneType , opaque = False , opaque_is_equal = None , ), 'name' : FieldMetadata ( node = False , kind = None , opaque = True , opaque_is_equal = None , ) } Changing field metadata If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Field Metadata"},{"location":"user-guide/field-metadata/#changing-field-metadata","text":"If at anypoint you want to change the metadata of any field you can do so by using the update_field_metadata method. For example, imagine we have this definition of BatchNorm: class BatchNorm ( to . Tree ): # nodes mean : jnp . ndarray = to . field ( node = True , kind = BatchStat ) ... # static features_in : int momentum : float ... model = BatchNorm ( features_in = 32 , momentum = 0.9 ) The momentum hyperparameter field is here is a float that you could even wish to make diffentiable in e.g. a meta-gradient setting, however, since the original author of the class didn't consider this its not a node, you can get around this by updating its metadata: class DifferentiableHyperParam : pass model = model . update_field_metadata ( 'momentum' , node = True , kind = DifferentiableHyperParam )","title":"Changing field metadata"},{"location":"user-guide/intro/","text":"User Guide Before we start it would be useful to define some terminology that will be used throughout the documentation. Terminology Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"User Guide"},{"location":"user-guide/intro/#user-guide","text":"Before we start it would be useful to define some terminology that will be used throughout the documentation.","title":"User Guide"},{"location":"user-guide/intro/#terminology","text":"Type Annotation : ( type hints ) types you set while defining a variable after the : symbol. Field Declaration : default values for class variables that are set using the field function. Node Field : A field that is declared as a node, that is, its content is part of the tree leaves. Static Field : A field that is declared as a static, that is, its content is not part of the leaves. Field Kind : An associated type, separate from the type annotation, that gives semantic meaning to the field. In code these terms map to the following: class MyModule ( to . Tree ): # field annotation -----------declaration------------- # v v v v some_field : jnp . ndarray = to . field ( node = True , kind = Parameter ) # ^ ^ # node status field kind","title":"Terminology"},{"location":"user-guide/node-policy/","text":"If a field is not marked with to.field the following policy will be applied when determining whether a field is a node or not: If the field is annotated with a Tree subtype or a generic containing a Tree subtype e.g. List[to.Tree] , the field is considered a node . If the runtime value of the field is a to.Tree instance, the field is considered a node and the Tree 's metadata will be updated to reflect this. If none of the above apply, the field is considered a static field. import treeo as to class Agent ( to . Tree ): ... class Game ( to . Tree ): player : Agent # node cpus : List [ Agent ] # node max_cpus : int # static def __init__ ( self , ... ): ... self . boss = Agent ( ... ) # runtime node Note: the kind of all fields that are not explicitly declarated is set to NoneType .","title":"Node policy"},{"location":"user-guide/non-hashable-static-fields/","text":"Static fields are required to be hashable by JAX, so what happens if you want to have a static field that contains a non-hashable value like a numpy or jax array? For example: import treeo as to @dataclass class MyTree ( to . Tree ): table : np . ndarray One solution is to make that field opaque , this will work as long as you don't need jit and friends to reach to changes to its value content for recompiling. If you do, you can instead use the to.Hashable(value) class to wrap around it like this: @dataclass class MyTree ( to . Tree ): table : to . Hashable [ np . ndarray ] The hash from Hashable will only depend on object identity but not on the actual value , therefore you should treat it as immutable, if you want to update its content you should create a new Hashable instance: table = to . Hasable ( np . ones (( 10 , 10 ))) tree = MyTree ( table ) @jax . jit def do_something ( tree : MyTree ): table_value = tree . table . value # use Hashable.value ... tree = do_something ( tree ) # compiles tree = do_something ( tree ) # uses cache # update table module . table = to . Hashable ( np . zeros (( 10 , 10 ))) tree = do_something ( tree ) # recompiles Warning : If you are somehow able to mutate Hashable.value directly JAX won't know about this and jit won't recompile.","title":"Non-hashable static fields"},{"location":"user-guide/opaque-static-fields/","text":"When the value of a static field changes jit and friends will recompile to reflect posible changes in the computation logic. While this is good quality in many cases, sometimes certain fields are just there for metadata and should not part of the actual computation. For example, name in the Person example above will probably not affect the logic yet in this example it will force recompilation: @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # re-compiles \ud83d\ude41 To avoid this, you can mark a field as opaque : @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) name : str = to . field ( node = False , opaque = True ) @jax . jit def do_something ( person : Person ): ... do_something ( Person ( height = 1.5 , name = 'John' )) # compiles do_something ( Person ( height = 1.5 , name = 'Fred' )) # cached! \ud83e\udd29 opaque will \"hide\" the value content of the field from JAX, changes will only be detected if the type of an opaque field changes or, in case its an array-like type, if its shape or dtype changes. opaque_is_equal If you want to define you on policy on how opaque fields are handled, you can use the opaque_is_equal: Callable[[to.Opaque, Any], bool] argument and pass a function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = True , opaque_is_equal = same_length , )","title":"Opaque static fields"},{"location":"user-guide/opaque-static-fields/#opaque_is_equal","text":"If you want to define you on policy on how opaque fields are handled, you can use the opaque_is_equal: Callable[[to.Opaque, Any], bool] argument and pass a function that takes in a to.Opaque(value: Any) object and the new value of the field and return a boolean indicating whether the new value is considered equal to the opaque value. def same_length ( opaque : to . Opaque , other : Any ): if ( isinstance ( other , to . Opaque ) and type ( opaque . value ) == type ( other . value ) ): if isinstance ( opaque . value , list ): return len ( opaque . value ) == len ( other . value ) else : return True else : return False @dataclass class Person ( to . Tree ): height : float = to . field ( node = True ) names : List [ str ] = to . field ( node = False , opaque = True , opaque_is_equal = same_length , )","title":"opaque_is_equal"},{"location":"user-guide/state-management/","text":"Treeo takes a \"direct\" approach to state management, i.e., state is updated in-place by the Tree whenever it needs to. For example, this module will calculate the running average of its input: @dataclass class Average ( to . Tree ): count : State [ jnp . ndarray ] = jnp . array ( 0 ) total : State [ jnp . ndarray ] = jnp . array ( 0.0 ) def __call__ ( self , x ): self . count += np . prod ( x . shape ) self . total += jnp . sum ( x ) return self . total / self . count What is the catch? State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . merge ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"State Management"},{"location":"user-guide/state-management/#what-is-the-catch","text":"State management is one of the most challenging things in JAX, but with the help of Treeo it seems effortless, what is the catch? As always there is a trade-off to consider: Treeo's approach requires to consider how to propagate state changes properly while taking into account the fact that Pytree operations create new objects, that is, since reference do not persist across calls through these functions changes might be lost. A standard solution to this problem is: always output the Tree to update state . For example, a typical gradient function in a Deep Learning application that contains a stateful Tree would look like this: @partial ( jax . value_and_grad , has_aux = True ) def grad_fn ( params , model , x , y ): model = to . merge ( model , params ) y_pred = model ( x ) # state is updated loss = jnp . mean (( y_pred - y ) ** 2 ) return loss , model # return model to propagate state changes params = to . filter ( model , Parameter ) ( loss , model ), grads = grad_fn ( params , model , x , y ) ... Here model is returned along with the loss through value_and_grad to update model on the outside thus persisting any changes to the state performed on the inside.","title":"What is the catch?"},{"location":"user-guide/sugar/","text":"For pedagogical reason, field has been used throught the documentation to reinforce the concepts, however, Treeo has a couple of shortcuts to make it easier and more understandable to define Trees. normal shortcut to.field(node=True) to.node() to.field(node=False) to.static() to.field(node=True, kind=Kind) Kind.node() to.field(node=False, kind=Kind) Kind.static() Based on this, you can take the following code class Parameter : pass class Child ( to . Tree ): a : float = to . field ( node = True ) b : str = to . field ( node = False ) b : float = to . field ( node = True , kind = Parameter ) d : float = to . field ( node = False , kind = Parameter ) class Parent ( to . Tree ): child1 : Child = to . field ( node = True ) child2 : Child = to . field ( node = False ) rest : List [ Child ] = to . field ( node = True ) and simplify it to: class Parameter ( to . KindMixin ): pass class Child ( to . Tree ): a : float = to . node () b : str # = to.static(), inferred b : float = Parameter . node () d : float = Parameter . static () class Parent ( to . Tree ): child1 : Child # = to.node(), inferred child2 : Child = to . static () rest : List [ Child ] # = to.node(), inferred The to.KindMixin provides the .field() , .node() , and .static() methods to subtypes, in this case the Parameter class.","title":"Sugar \ud83c\udf6c"},{"location":"user-guide/api/filter/","text":"Filter The filter function allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: jax . tree_map ( lambda x : - x , to . filter ( tree , Parameter )) # MyTree(a=-1, b=Nothing) jax . tree_map ( lambda x : - x , to . filter ( tree , BatchStat )) # MyTree(a=Nothing, b=-2) filter predicates If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np .2 , jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.2, jnp.array([3.0, 4.0])] multiple filters You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) inplace If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Filter"},{"location":"user-guide/api/filter/#filter","text":"The filter function allows you to select a subtree by filtering based on a kind , all leaves whose field kind is a subclass of such type are kept, the rest are set to a special Nothing value. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . filter ( tree , Parameter ) # MyTree(a=1, b=Nothing) to . filter ( tree , BatchStat ) # MyTree(a=Nothing, b=2) Since Nothing is an empty Pytree it gets ignored by tree operations, this effectively allows you to easily operate on a subset of the fields: jax . tree_map ( lambda x : - x , to . filter ( tree , Parameter )) # MyTree(a=-1, b=Nothing) jax . tree_map ( lambda x : - x , to . filter ( tree , BatchStat )) # MyTree(a=Nothing, b=-2)","title":"Filter"},{"location":"user-guide/api/filter/#filter-predicates","text":"If you need to do more complex filtering, you can pass callables with the signature FieldInfo -> bool instead of types: # all Parameters whose field name is \"kernel\" to . filter ( tree , lambda field : issubclass ( field . kind , Parameter ) and field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing) Since filter works with pytrees in general, the following is possible: def array_like ( field ): return hasattr ( field . value , \"shape\" ) and hasattr ( field . value , \"dtype\" ) tree = [ 1 , np .2 , jnp . array ([ 3.0 , 4.0 ])] to . filter ( tree , array_like ) # [Nothing, np.2, jnp.array([3.0, 4.0])]","title":"filter predicates"},{"location":"user-guide/api/filter/#multiple-filters","text":"You can some queries by using multiple filters as *args . For a field to be kept it will required that all filters pass . Since passing types by themselves are \"kind filters\", one of the previous examples could be written as: # all Parameters whose field name is \"kernel\" to . filter ( tree , Parameter , lambda field : field . name == \"kernel\" ) # MyTree(a=Nothing, b=Nothing)","title":"multiple filters"},{"location":"user-guide/api/filter/#inplace","text":"If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"inplace"},{"location":"user-guide/api/map/","text":"Map Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/map/#map","text":"Applies a function to all leaves in a pytree using jax.tree_map . If filters are given then the function will be applied only to the subset of leaves that match the filters. For example, if we want to zero all batch stats we can do: Example: @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) tree = MyTree ( a = 1 , b = 2 ) to . map ( lambda _ : 0 , tree , BatchStat ) # MyTree(a=1, b=0) map is equivalent to filter -> tree_map -> merge in sequence. If inplace is True , the input obj is mutated and returned. You can only update inplace if the input obj has a __dict__ attribute, else a TypeError is raised.","title":"Map"},{"location":"user-guide/api/merge/","text":"Merge Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) merge ( t1 , t2 ) # MyTree(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be merged. If flatten_mode=\"normal\" is set then static fields won't be merged and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Trees the following equivalence holds: merge(m1, m2, m3) = merge(m1, merge(m2, m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) merge ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"},{"location":"user-guide/api/merge/#merge","text":"Creates a new Tree with the same structure but its values merged based on the values from the incoming Trees. @dataclass class MyTree ( to . Tree ): a : int = to . field ( node = True , kind = Parameter ) b : int = to . field ( node = True , kind = BatchStat ) t1 = MyTree ( x = Nothing , y = 2 , z = 3 ) t2 = MyTree ( x = 1 , y = Nothing , z = 4 ) merge ( t1 , t2 ) # MyTree(x=1, y=2, z=4) Updates are performed using the following rules: For a list of equivalent leaves l1, l2, ..., ln , it returns the first non- Nothing leaf from right to left. If no flatten_mode() context manager is active and flatten_mode is not given, all fields will be merged. If flatten_mode=\"normal\" is set then static fields won't be merged and the output will have the exact same static components as the first input ( obj ). When using merge with multiple Trees the following equivalence holds: merge(m1, m2, m3) = merge(m1, merge(m2, m3)) If you want to merge the current module instead of creating a new one use inplace=True . This is useful when applying transformation inside a method where reassigning self is not possible: def double_params ( self ): # this is not doing what you expect self = jax . tree_map ( lambda x : 2 * x , self ) Instead do this: def double_params ( self ): doubled = jax . tree_map ( lambda x : 2 * x , self ) merge ( self , doubled , inplace = True ) If inplace is True , the input obj is mutated and returned. You can only merge inplace if the input obj has a __dict__ attribute, else a TypeError is raised. If ignore_static is True , static fields (according to the flattening mode) will be bypassed during the merge process, the final output will have the same static components as the first input ( obj ). This strategy is a bit less safe in general as it will flatten all trees using jax.tree_leaves instead of PyTreeDef.flatten_up_to , this skips some checks so it effectively ignores their static components, the only requirement is that the flattened struture of all trees matches.","title":"Merge"}]}